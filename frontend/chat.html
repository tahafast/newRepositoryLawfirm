<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
  <meta http-equiv="Pragma" content="no-cache"/>
  <meta http-equiv="Expires" content="0"/>
  <title>BRAG AI â€” Chat</title>
  <link rel="stylesheet" href="./styles.css?v=1.1.3"/>
  <script src="./theme.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    /* Chat-specific overrides that work with theme.js */
    :root {
      --sidebar: #ffffff;
      --panel: #f8fafc;
      --chat-bg: #f3f7ff;
      --hover: #e5e7eb;
    }

    :root[data-theme="dark"] {
      --sidebar: #0f172a;
      --panel: #0b1220;
      --chat-bg: #0b1120;
      --hover: #1e293b;
    }

    body {
      margin: 0;
      background: var(--chat-bg);
      color: var(--text);
      font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      overflow: hidden;
    }

    .app {
      display: flex;
      flex: 1;
      min-height: 0;
    }

    /* Sidebar */
    .sidebar {
      width: 280px;
      background: var(--sidebar);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .sb-head {
      padding: 14px;
      border-bottom: 1px solid var(--border);
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .sb-head .brand {
      flex: 1;
      font-weight: 600;
      font-size: 0.95rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .sb-head .brand img {
      width: 24px;
      height: 24px;
    }

    .chat-btn {
      background: var(--panel);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.875rem;
      white-space: nowrap;
      transition: all 0.2s;
    }

    .chat-btn:hover {
      border-color: var(--brand);
      background: var(--hover);
    }

    .chat-btn.primary {
      background: var(--brand);
      border-color: var(--brand);
      color: #fff;
      font-weight: 500;
    }

    .chat-btn.primary:hover {
      background: var(--brand-600);
      border-color: var(--brand-600);
    }

    .conv-list {
      overflow-y: auto;
      padding: 8px;
      flex: 1;
    }

    .conv {
      padding: 10px 12px;
      border-radius: 8px;
      margin: 4px 0;
      cursor: pointer;
      background: transparent;
      border: 1px solid transparent;
      transition: all 0.15s;
      font-size: 0.9rem;
      position: relative;
      display: flex;
      flex-direction: column;
    }

    .conv:hover {
      background: var(--hover);
      border-color: #213044;
    }

    .conv.active {
      background: var(--panel);
      border-color: var(--accent);
    }

    .conv.has-doc::after {
      content: "DOC";
      position: absolute;
      top: 6px;
      right: 8px;
      font-size: 0.65rem;
      font-weight: 600;
      color: var(--brand);
      letter-spacing: 0.05em;
    }

    .conv-title {
      font-weight: 500;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      padding-right: 30px;
    }

    .conv-date {
      font-size: 0.75rem;
      color: var(--muted);
      margin-top: 4px;
    }

    .delete-chat {
      position: absolute;
      top: 10px;
      right: 8px;
      background: #dc2626;
      border: 1px solid #b91c1c;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.85rem;
      opacity: 0;
      transform: scale(0.8);
      transition: all 0.2s;
      z-index: 10;
    }

    .conv:hover .delete-chat {
      opacity: 1;
      transform: scale(1);
    }

    .delete-chat:hover {
      background: #b91c1c;
      border-color: #991b1b;
    }

    .streaming-cursor {
      display: inline-block;
      width: 2px;
      height: 1em;
      background: var(--brand);
      margin-left: 2px;
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0; }
    }

    /* Main content */
    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .chat-header {
      padding: 14px 20px;
      border-bottom: 1px solid var(--border);
      background: var(--sidebar);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .chat-header h2 {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
    }

    .chat {
      flex: 1;
      overflow-y: auto;
      padding: 20px 24px;
      background: var(--chat-bg);
    }

    .bubble {
      max-width: 800px;
      margin: 16px 0;
      padding: 16px 18px;
      border-radius: 12px;
      background: var(--panel);
      border: 1px solid var(--border);
      line-height: 1.6;
    }

    .bubble.user {
      background: var(--panel);
      margin-left: auto;
      max-width: 600px;
      border-left: 3px solid var(--brand);
    }

    .bubble.assistant {
      background: var(--panel);
      border-left: 3px solid var(--success);
    }

    .bubble strong {
      display: block;
      margin-bottom: 8px;
      color: var(--brand);
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .bubble.user strong {
      color: var(--brand-600);
    }

    .assistant-card h2,
    .assistant-card h3 {
      margin: 12px 0 8px;
    }

    .assistant-card p {
      margin: 8px 0;
      line-height: 1.6;
    }

    .assistant-card ul {
      margin: 8px 0 8px 18px;
    }

    .meta-row {
      margin: 8px 0 0;
      font-size: 0.85rem;
      opacity: 0.8;
      color: var(--muted);
    }

    .composer {
      display: flex;
      gap: 8px;
      padding: 14px 20px;
      border-top: 1px solid var(--border);
      background: var(--sidebar);
    }

    textarea {
      flex: 1;
      background: var(--panel);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      min-height: 48px;
      max-height: 150px;
      resize: vertical;
      font-family: inherit;
      font-size: 0.95rem;
    }

    textarea:focus {
      outline: none;
      border-color: var(--accent);
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: #374151;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #4b5563;
    }

    .loading {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid var(--border);
      border-top-color: var(--brand);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .streaming-cursor {
      background: var(--brand);
    }

    /* Styling for rendered HTML documents (doc-gen) */
    .html-document {
      background: white !important;
      color: #000 !important;
      padding: 40px !important;
      font-family: 'Times New Roman', Times, serif !important;
      line-height: 1.6 !important;
      max-width: 100% !important;
      border: 1px solid #ddd !important;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
    }

    /* Dark mode: keep document white (like a paper) */
    :root[data-theme="dark"] .html-document {
      background: white !important;
      color: #000 !important;
      border: 1px solid #555 !important;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3) !important;
    }

    .html-document p {
      margin: 12px 0 !important;
      text-align: justify !important;
      color: #000 !important;
    }

    .html-document ol {
      margin: 16px 0 !important;
      padding-left: 24px !important;
    }

    .html-document ol li {
      margin: 8px 0 !important;
      text-align: justify !important;
      color: #000 !important;
    }

    .html-document h1, .html-document h2, .html-document h3 {
      text-align: center !important;
      margin: 16px 0 !important;
      font-weight: bold !important;
      text-transform: uppercase !important;
      color: #000 !important;
    }

    .html-document table {
      margin: 16px auto !important;
      border-collapse: collapse !important;
    }

    .html-document table td {
      padding: 8px !important;
      color: #000 !important;
    }

    /* Ensure all nested elements in html-document stay black on white */
    .html-document * {
      color: #000 !important;
    }
  </style>
</head>
<body>
  <header class="header flex items-center justify-between px-6 py-4">
    <div class="flex items-center space-x-3">
      <div class="logo bg-blue-600 text-white font-bold rounded-full w-8 h-8 flex items-center justify-center text-lg">B</div>
      <span class="brand text-lg font-semibold tracking-wide text-gray-900 dark:text-white">BRAG AI (LEGAL)</span>
    </div>
    <nav class="flex items-center space-x-4">
      <a href="./index.html" class="text-sm font-medium hover:underline">Home</a>
      <a href="./ingest.html" class="text-sm font-medium hover:underline">Ingest</a>
      <a href="./chat.html" class="text-sm font-medium hover:underline">Chat</a>
      <button onclick="__bragaiTheme.toggleTheme()" data-theme-toggle class="theme-toggle border rounded-xl px-3 py-1 text-sm flex items-center">
        &#127769; Dark
      </button>
    </nav>
  </header>

  <div class="app">
  <!-- Sidebar -->
  <aside class="sidebar">
    <div class="sb-head" style="border-top: 1px solid var(--border); border-bottom: none;">
      <button class="chat-btn primary" id="newChat" style="flex: 1;">+ New Chat</button>
      <button class="chat-btn" id="refreshChats" title="Refresh conversations">â†»</button>
    </div>
    <div class="conv-list" id="convList"></div>
  </aside>

  <!-- Main chat area -->
  <main class="main">
    <div class="chat-header">
      <h2>Chat</h2>
    </div>
    <div class="chat" id="transcript"></div>
    <div class="composer">
      <textarea id="input" placeholder="Ask anything about your documents..." rows="1"></textarea>
      <button class="chat-btn primary" id="send">Send</button>
    </div>
  </main>
  </div>

  <script type="module">
  import { API_BASE } from "./config.runtime.js?v=2025-10-13-dark-fix";

  const API = API_BASE + '/api/v1/lawfirm';
  let conversationId = localStorage.getItem('conversation_id') || null;
  const userId = localStorage.getItem('user_id') || 'anon';

  const convList = document.getElementById('convList');
  const transcript = document.getElementById('transcript');
  const input = document.getElementById('input');
  const sendBtn = document.getElementById('send');

  const CHAT_STATE_KEY = 'chat_state_meta';
  let chatState = {};
  try {
    chatState = JSON.parse(localStorage.getItem(CHAT_STATE_KEY) || '{}');
  } catch (e) {
    console.warn('[CHAT-STATE] Failed to parse chat state cache, resetting.', e);
    chatState = {};
  }

  const TWEAK_TRIGGERS = [
    'tweak','revise','modify','simplify','edit','tone','change','update','add','remove','replace'
  ];

  function getChatHasDoc(id) {
    return !!(chatState[id] && chatState[id].hasDoc);
  }

  function setChatHasDoc(id, value) {
    if (!id) return;
    chatState[id] = { ...(chatState[id] || {}), hasDoc: !!value };
    localStorage.setItem(CHAT_STATE_KEY, JSON.stringify(chatState));
  }

  function clearChatState(id) {
    if (!id || !chatState[id]) return;
    delete chatState[id];
    localStorage.setItem(CHAT_STATE_KEY, JSON.stringify(chatState));
  }

  function ensureChatSubject(id, userInput) {
    if (!id) return;
    const currentSubject = getChatTitle(id);
    if (currentSubject && currentSubject.trim() && currentSubject.trim().toLowerCase() !== "new chat") {
      return;
    }

    const original = (userInput || "").trim();
    if (!original) {
      return;
    }

    const lower = original.toLowerCase();
    let subject = "New chat";
    if (lower.includes("legal notice")) subject = "Legal notice generation request";
    else if (lower.includes("suit")) subject = "Suit drafting request";
    else if (lower.includes("petition")) subject = "Petition drafting request";
    else if (lower.includes("application")) subject = "Application drafting request";
    else if (lower.includes("bail")) subject = "Bail application drafting request";
    else if (lower.includes("affidavit")) subject = "Affidavit preparation request";
    else subject = original.charAt(0).toUpperCase() + original.slice(1);

    updateSidebarTitle(id, subject);
    chatState[id] = { ...(chatState[id] || {}), subjectLocked: true };
    localStorage.setItem(CHAT_STATE_KEY, JSON.stringify(chatState));
  }

  // Helper to detect if text is HTML (starts with <html>, <div>, <!DOCTYPE, etc.)
  function isHtmlContent(text) {
    const trimmed = (text || '').trim();
    
    // Debug: log first 200 chars to see what we're getting
    console.log('[HTML-DETECT] First 200 chars:', trimmed.substring(0, 200));
    console.log('[HTML-DETECT] Starts with <:', trimmed.startsWith('<'));
    console.log('[HTML-DETECT] Contains </:', trimmed.includes('</'));
    console.log('[HTML-DETECT] Length:', trimmed.length);
    
    // Check for common HTML patterns that indicate document generation
    const isHtml = trimmed.startsWith('<!DOCTYPE') || 
           trimmed.startsWith('<html') || 
           trimmed.startsWith('<div>') ||
           trimmed.startsWith('<div ') ||
           trimmed.match(/^<p>/) ||
           trimmed.match(/^<ol>/) ||
           // More aggressive: if it starts with < and has HTML tags, treat as HTML
           (trimmed.startsWith('<') && (trimmed.includes('</p>') || trimmed.includes('</div>') || trimmed.includes('</ol>')) && trimmed.length > 100);
    
    console.log('[HTML-DETECT] Result:', isHtml);
    return isHtml;
  }

  function bubble(role, text, isMarkdown = false, referencedPages = null, documentName = null, responseType = null) {
    const div = document.createElement('div');
    div.className = 'bubble ' + (role === 'user' ? 'user' : 'assistant');
    
    const roleLabel = document.createElement('strong');
    roleLabel.textContent = role;
    div.appendChild(roleLabel);

    if (role === 'assistant' && isMarkdown) {
      const answerBox = document.createElement('div');
      answerBox.className = 'assistant-card answer-content';
      
      // Check if content is HTML (doc-gen output) or Markdown (QA output)
      const treatAsHtml = responseType === 'html' || isHtmlContent(text);
      if (treatAsHtml) {
        // Render HTML directly for document generation
        answerBox.className = 'assistant-card answer-content html-document';
        answerBox.innerHTML = text;
        console.log('[HTML-DOC] Rendering as HTML document');
      } else {
        // Parse as markdown for QA responses
        answerBox.innerHTML = marked.parse(text);
        console.log('[MARKDOWN] Rendering as markdown');
      }
      
      div.appendChild(answerBox);

      // Add metadata
      if (referencedPages || documentName) {
        const metaDiv = document.createElement('div');
        metaDiv.className = 'meta-row';
            const rows = [];
        if (referencedPages && referencedPages.length > 0) {
          rows.push(`Reference pages: ${referencedPages.join(', ')}`);
        }
        if (documentName) {
          rows.push(`Document: ${documentName}`);
        }
        metaDiv.textContent = rows.join(' | ');
            div.appendChild(metaDiv);
          }
        } else {
      const content = document.createElement('div');
      content.textContent = text;
      div.appendChild(content);
    }

    transcript.appendChild(div);
    transcript.scrollTop = transcript.scrollHeight;
  }

  function escapeHtml(str) {
    return (str || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  async function listConversations() {
    try {
      const r = await fetch(`${API}/conversations?user_id=${encodeURIComponent(userId)}`);
      const data = await r.json();
      convList.innerHTML = '';
      
      if (data.length === 0) {
        const empty = document.createElement('div');
        empty.style.padding = '16px';
        empty.style.textAlign = 'center';
        empty.style.color = 'var(--muted)';
        empty.style.fontSize = '0.875rem';
        empty.textContent = 'No conversations yet';
        convList.appendChild(empty);
        return;
      }

      data.forEach(c => {
        const item = document.createElement('div');
        item.className = 'conv' + (c.id === conversationId ? ' active' : '');
        item.dataset.convId = c.id; // Add data attribute for easier selection
        if (getChatHasDoc(c.id)) {
          item.classList.add('has-doc');
        }
        
        const title = document.createElement('div');
        title.className = 'conv-title';
        // Use persisted title from localStorage if available
        title.textContent = getChatTitle(c.id);
        item.appendChild(title);

        const date = document.createElement('div');
        date.className = 'conv-date';
        const d = new Date(c.created_at);
        date.textContent = d.toLocaleDateString() + ' ' + d.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
        item.appendChild(date);

        // Delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-chat';
        deleteBtn.innerHTML = 'ðŸ—‘ï¸';
        deleteBtn.title = 'Delete conversation';
        deleteBtn.onclick = async (e) => {
          e.stopPropagation();
          if (confirm('Delete this conversation?')) {
            await deleteConversation(c.id);
          }
        };
        item.appendChild(deleteBtn);

        item.onclick = async () => {
          conversationId = c.id;
          localStorage.setItem('conversation_id', conversationId);
          await loadMessages();
          await listConversations(); // Refresh to update active state
        };
        
        convList.appendChild(item);
      });
    } catch (e) {
      console.error('Failed to list conversations:', e);
    }
  }

  async function deleteConversation(convId) {
    try {
      await fetch(`${API}/conversations/${convId}`, {
        method: 'DELETE'
      });
      clearChatState(convId);
      
      // If we deleted the current conversation, clear it
      if (convId === conversationId) {
        conversationId = null;
        localStorage.removeItem('conversation_id');
        transcript.innerHTML = '';
        
        // Load first available conversation or create new one
        const r = await fetch(`${API}/conversations?user_id=${encodeURIComponent(userId)}`);
        const convs = await r.json();
        
        if (convs.length > 0) {
          conversationId = convs[0].id;
          localStorage.setItem('conversation_id', conversationId);
          await loadMessages();
        } else {
          await newConversation();
        }
      }
      
      await listConversations();
    } catch (e) {
      console.error('Failed to delete conversation:', e);
      alert('Failed to delete conversation. Please try again.');
    }
  }

  async function newConversation() {
    try {
      const r = await fetch(`${API}/conversations/new`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({user_id: userId})
      });
      const data = await r.json();
      conversationId = data.conversation_id;
      localStorage.setItem('conversation_id', conversationId);
      setChatHasDoc(conversationId, false);
      transcript.innerHTML = '';
      await listConversations();
    } catch (e) {
      console.error('Failed to create conversation:', e);
    }
  }

  async function loadMessages() {
    if (!conversationId) {
      await newConversation();
      return;
    }
    
    try {
      const r = await fetch(`${API}/conversations/${conversationId}/messages`);
      const data = await r.json();
      transcript.innerHTML = '';
      data.forEach(m => {
        // Check if message has markdown metadata (for assistant messages)
        const isMarkdown = m.role === 'assistant';
        const respType = (m?.metadata && m.metadata.response_type) || m?.response_type || null;
        const hasDocMeta = m?.metadata && Object.prototype.hasOwnProperty.call(m.metadata, 'has_doc') ? m.metadata.has_doc : undefined;
        if (typeof hasDocMeta === 'boolean') {
          setChatHasDoc(conversationId, hasDocMeta);
        } else if (respType === 'html') {
          setChatHasDoc(conversationId, true);
        }
        bubble(m.role, m.content, isMarkdown, null, null, respType);
      });
    } catch (e) {
      console.error('Failed to load messages:', e);
    }
  }

  document.getElementById('newChat').onclick = newConversation;
  document.getElementById('refreshChats').onclick = listConversations;

  document.getElementById('send').onclick = send;
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      send();
    }
  });

  // Streaming helper - displays text word by word
  async function streamResponse(bubbleDiv, fullText, responseType = null) {
    const contentDiv = bubbleDiv.querySelector('.answer-content') || bubbleDiv.querySelector('div:last-child');
    if (!contentDiv) return;

    // Check if content is HTML - if so, render immediately without streaming
    const treatAsHtml = responseType === 'html' || isHtmlContent(fullText);
    if (treatAsHtml) {
      contentDiv.className = 'assistant-card answer-content html-document';
      contentDiv.innerHTML = fullText;
      transcript.scrollTop = transcript.scrollHeight;
      console.log('[HTML-DOC] Rendered HTML document in streaming');
      return;
    }

    // Stream markdown content word by word
    const words = fullText.split(' ');
    let displayedText = '';
    
    // Add cursor
    const cursor = document.createElement('span');
    cursor.className = 'streaming-cursor';
    contentDiv.appendChild(cursor);

    for (let i = 0; i < words.length; i++) {
      displayedText += (i > 0 ? ' ' : '') + words[i];
      
      // Update content - use innerHTML for markdown-like formatting
      contentDiv.innerHTML = displayedText.replace(/\n/g, '<br>');
      contentDiv.appendChild(cursor);
      
      // Smooth scroll
      transcript.scrollTop = transcript.scrollHeight;
      
      // Word-by-word delay (adjust speed here)
      await new Promise(resolve => setTimeout(resolve, 30));
    }
    
    // Remove cursor and render final markdown
    cursor.remove();
    contentDiv.innerHTML = marked.parse(fullText);
  }

  // --- Sidebar title helpers with localStorage persistence ---
  function normalizeTitleFromText(text) {
    if (!text) return "New Chat";
    const words = text.trim().replace(/\s+/g, ' ').split(' ').slice(0, 7).join(' ');
    const capped = words.charAt(0).toUpperCase() + words.slice(1);
    return capped.length > 40 ? capped.slice(0, 37) + 'â€¦' : capped;
  }
  
  function saveChatTitle(conversationId, title) {
    const map = JSON.parse(localStorage.getItem('chatTitles') || '{}');
    map[conversationId] = title;
    localStorage.setItem('chatTitles', JSON.stringify(map));
  }
  
  function getChatTitle(conversationId) {
    const map = JSON.parse(localStorage.getItem('chatTitles') || '{}');
    return map[conversationId] || "New Chat";
  }
  
  function updateSidebarTitle(conversationId, newTitle) {
    const item = document.querySelector(`[data-conv-id="${conversationId}"] .conv-title`);
    if (item) {
      if (item.textContent.trim() === "New Chat") {
        item.textContent = newTitle;
      }
    }
    saveChatTitle(conversationId, newTitle);
  }
  
  // Helper function to generate title from first user message (legacy support)
  function generateTitleFromMessage(text) {
    return normalizeTitleFromText(text);
  }
  
  // Update chat title in sidebar (only if it's "New Chat") - legacy support
  function updateChatTitleInSidebar(convId, newTitle) {
    updateSidebarTitle(convId, newTitle);
  }

  async function send() {
    const text = input.value.trim();
    if (!text) return;

    if (conversationId && getChatHasDoc(conversationId)) {
      const lower = text.toLowerCase();
      if (TWEAK_TRIGGERS.some(trigger => lower.includes(trigger))) {
        console.log('[DOC-TWEAK] Applying tweak to existing document context.');
      }
    }

    if (conversationId && getChatHasDoc(conversationId)) {
      const lower = text.toLowerCase();
      if (TWEAK_TRIGGERS.some(trigger => lower.includes(trigger))) {
        console.log('[DOC-TWEAK] Applying tweak to existing document context.');
      }
    }

    bubble('user', text);
    input.value = '';
    sendBtn.disabled = true;

    if (!conversationId) await newConversation();

    // Create assistant bubble with loading
    const assistantDiv = document.createElement('div');
    assistantDiv.className = 'bubble assistant';
    const roleLabel = document.createElement('strong');
    roleLabel.textContent = 'assistant';
    assistantDiv.appendChild(roleLabel);
    
    const contentDiv = document.createElement('div');
    contentDiv.className = 'assistant-card answer-content';
    contentDiv.innerHTML = '<div style="display: flex; align-items: center; gap: 8px;"><span class="loading"></span><span>Thinking...</span></div>';
    assistantDiv.appendChild(contentDiv);
    
    transcript.appendChild(assistantDiv);
    transcript.scrollTop = transcript.scrollHeight;

    try {
      const storedConversation = localStorage.getItem('conversation_id');
      if (storedConversation) {
        conversationId = storedConversation;
      }

      const body = {
        query: text,
        conversation_id: conversationId,
        user_id: userId
      };
      
      const r = await fetch(`${API}/query`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(body)
      });
      
      const data = await r.json();

      // Update conversation_id from response
      if (data?.metadata?.conversation_id) {
        conversationId = data.metadata.conversation_id;
        localStorage.setItem('conversation_id', conversationId);
      }

      // Clear loading and stream response
      const content = data?.answer || '[no answer]';
      contentDiv.innerHTML = '';
      
      const responseType = data?.metadata?.response_type || null;
      const hasDocMeta = data?.metadata?.has_doc;
      if (typeof hasDocMeta === 'boolean') {
        setChatHasDoc(conversationId, hasDocMeta);
      } else if (responseType === 'html') {
        setChatHasDoc(conversationId, true);
      }
      await streamResponse(assistantDiv, content, responseType);
      ensureChatSubject(conversationId, text);
      
      // Add metadata after streaming
      const pages = data?.metadata?.referenced_pages;
      const doc = data?.metadata?.document;
      const docType = data?.metadata?.doc_type;
      const references = Array.isArray(data?.metadata?.references) ? data.metadata.references.filter(Boolean) : [];
      
      if ((pages && pages.length) || doc || (docType && docType !== 'general') || references.length) {
        const metaDiv = document.createElement('div');
        metaDiv.className = 'meta-row';
        const rows = [];
        if (pages && pages.length > 0) {
          rows.push(`Reference pages: ${pages.join(', ')}`);
        }
        if (doc) {
          rows.push(`Document: ${doc}`);
        }
        if (docType && docType !== 'general') {
          rows.push(`Document type: ${docType.replace(/_/g, ' ')}`);
        }
        if (references.length > 0) {
          rows.push(`Referenced from: ${references.join(', ')}`);
        }
        metaDiv.textContent = rows.join(' | ');
        assistantDiv.appendChild(metaDiv);
      }
      
      // Refresh conversation list
      await listConversations();
    } catch (e) {
      console.error('Query error:', e);
      contentDiv.innerHTML = `Error: ${escapeHtml(e?.message || e)}`;
    } finally {
      sendBtn.disabled = false;
      input.focus();
    }
  }

  // Initialize
  (async function init() {
    try {
      console.log('[INIT] Starting initialization...');
      if (!conversationId) {
        console.log('[INIT] No conversation ID, creating new...');
        await newConversation();
      }
      console.log('[INIT] Loading conversations...');
      await listConversations();
      console.log('[INIT] Loading messages...');
      await loadMessages();
      console.log('[INIT] Initialization complete');
      input.focus();
    } catch (e) {
      console.error('[INIT] Initialization failed:', e);
      alert('Failed to initialize chat. Please refresh the page.');
    }
  })();

  // Auto-resize textarea
  input.addEventListener('input', function() {
    this.style.height = 'auto';
    this.style.height = Math.min(this.scrollHeight, 150) + 'px';
  });
  </script>
  
</body>
</html>
