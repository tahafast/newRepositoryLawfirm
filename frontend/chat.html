<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
  <meta http-equiv="Pragma" content="no-cache"/>
  <meta http-equiv="Expires" content="0"/>
  <title>BRAG AI ΓÇö Chat</title>
  <link rel="stylesheet" href="./styles.css?v=1.1.3"/>
  <script src="./theme.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    /* Chat-specific overrides that work with theme.js */
    :root {
      --sidebar: #ffffff;
      --panel: #f8fafc;
      --chat-bg: #f3f7ff;
      --hover: #e5e7eb;
    }

    :root[data-theme="dark"] {
      --sidebar: #0f172a;
      --panel: #0b1220;
      --chat-bg: #0b1120;
      --hover: #1e293b;
    }

    body {
      margin: 0;
      background: var(--chat-bg);
      color: var(--text);
      font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      overflow: hidden;
    }

    .app {
      display: flex;
      flex: 1;
      min-height: 0;
    }

    /* Sidebar */
    .sidebar {
      width: 280px;
      background: var(--sidebar);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .sb-head {
      padding: 14px;
      border-bottom: 1px solid var(--border);
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .sb-head .brand {
      flex: 1;
      font-weight: 600;
      font-size: 0.95rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .sb-head .brand img {
      width: 24px;
      height: 24px;
    }

    .chat-btn {
      background: var(--panel);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.875rem;
      white-space: nowrap;
      transition: all 0.2s;
    }

    .chat-btn:hover {
      border-color: var(--brand);
      background: var(--hover);
    }

    .chat-btn.primary {
      background: var(--brand);
      border-color: var(--brand);
      color: #fff;
      font-weight: 500;
    }

    .chat-btn.primary:hover {
      background: var(--brand-600);
      border-color: var(--brand-600);
    }

    .conv-list {
      overflow-y: auto;
      padding: 8px;
      flex: 1;
    }

    .conv {
      padding: 10px 12px;
      border-radius: 8px;
      margin: 4px 0;
      cursor: pointer;
      background: transparent;
      border: 1px solid transparent;
      transition: all 0.15s;
      font-size: 0.9rem;
      position: relative;
      display: flex;
      flex-direction: column;
    }

    .conv:hover {
      background: var(--hover);
      border-color: #213044;
    }

    .conv.active {
      background: var(--panel);
      border-color: var(--accent);
    }

    .conv.has-doc::after {
      content: "DOC";
      position: absolute;
      top: 6px;
      right: 8px;
      font-size: 0.65rem;
      font-weight: 600;
      color: var(--brand);
      letter-spacing: 0.05em;
    }

    .conv-title {
      font-weight: 500;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      padding-right: 30px;
    }

    .conv-date {
      font-size: 0.75rem;
      color: var(--muted);
      margin-top: 4px;
    }

    .delete-chat {
      position: absolute;
      top: 10px;
      right: 8px;
      background: #dc2626;
      border: 1px solid #b91c1c;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.85rem;
      opacity: 0;
      transform: scale(0.8);
      transition: all 0.2s;
      z-index: 10;
    }

    .conv:hover .delete-chat {
      opacity: 1;
      transform: scale(1);
    }

    .delete-chat:hover {
      background: #b91c1c;
      border-color: #991b1b;
    }

    .streaming-cursor {
      display: inline-block;
      width: 2px;
      height: 1em;
      background: var(--brand);
      margin-left: 2px;
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0; }
    }

    /* Main content */
    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .chat-header {
      padding: 14px 20px;
      border-bottom: 1px solid var(--border);
      background: var(--sidebar);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .chat-header h2 {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
    }

    .chat {
      flex: 1;
      overflow-y: auto;
      padding: 20px 24px;
      background: var(--chat-bg);
    }

    .bubble {
      max-width: 800px;
      margin: 16px 0;
      padding: 16px 18px;
      border-radius: 12px;
      background: var(--panel);
      border: 1px solid var(--border);
      line-height: 1.6;
    }

    .bubble.user {
      background: var(--panel);
      margin-left: auto;
      max-width: 600px;
      border-left: 3px solid var(--brand);
    }

    .bubble.assistant {
      background: var(--panel);
      border-left: 3px solid var(--success);
    }

    .bubble strong {
      display: block;
      margin-bottom: 8px;
      color: var(--brand);
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .bubble.user strong {
      color: var(--brand-600);
    }

    .assistant-card h2,
    .assistant-card h3 {
      margin: 12px 0 8px;
    }

    .assistant-card p {
      margin: 8px 0;
      line-height: 1.6;
    }

    .assistant-card ul {
      margin: 8px 0 8px 18px;
    }

    .meta-row {
      margin: 8px 0 0;
      font-size: 0.85rem;
      opacity: 0.8;
      color: var(--muted);
    }

    .composer {
      display: flex;
      gap: 8px;
      padding: 14px 20px;
      border-top: 1px solid var(--border);
      background: var(--sidebar);
    }

    .chat-toolbar {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 20px;
      border-top: 1px solid var(--border);
      border-bottom: 1px solid var(--border);
      background: var(--sidebar);
    }

    .chat-toolbar .btn {
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background 0.2s, border 0.2s;
    }

    .chat-toolbar .btn:hover {
      background: var(--hover);
      border-color: var(--brand);
    }

    .chat-toolbar .btn[disabled] {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .chat-toolbar .muted {
      color: #6b7280;
      font-size: 0.75rem;
    }

    .ephemeral-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border-radius: 12px;
      background: #f1f5f9;
      font-size: 0.75rem;
    }

    :root[data-theme="dark"] .ephemeral-chip {
      background: #1e293b;
      color: #cbd5f5;
    }

    .ephemeral-chip button {
      border: none;
      background: transparent;
      cursor: pointer;
      font-size: 0.8rem;
      color: inherit;
    }

    .ephemeral-chip button:hover {
      opacity: 0.7;
    }

    textarea {
      flex: 1;
      background: var(--panel);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      min-height: 48px;
      max-height: 150px;
      resize: vertical;
      font-family: inherit;
      font-size: 0.95rem;
    }

    textarea:focus {
      outline: none;
      border-color: var(--accent);
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: #374151;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #4b5563;
    }

    .loading {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid var(--border);
      border-top-color: var(--brand);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .streaming-cursor {
      background: var(--brand);
    }

    /* Styling for rendered HTML documents (doc-gen) */
    .html-document {
      background: white !important;
      color: #000 !important;
      padding: 40px !important;
      font-family: 'Times New Roman', Times, serif !important;
      line-height: 1.6 !important;
      max-width: 100% !important;
      border: 1px solid #ddd !important;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
    }

    /* Dark mode: keep document white (like a paper) */
    :root[data-theme="dark"] .html-document {
      background: white !important;
      color: #000 !important;
      border: 1px solid #555 !important;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3) !important;
    }

    .html-document p {
      margin: 12px 0 !important;
      text-align: justify !important;
      color: #000 !important;
    }

    .html-document ol {
      margin: 16px 0 !important;
      padding-left: 24px !important;
    }

    .html-document ol li {
      margin: 8px 0 !important;
      text-align: justify !important;
      color: #000 !important;
    }

    .html-document h1, .html-document h2, .html-document h3 {
      text-align: center !important;
      margin: 16px 0 !important;
      font-weight: bold !important;
      text-transform: uppercase !important;
      color: #000 !important;
    }

    .html-document table {
      margin: 16px auto !important;
      border-collapse: collapse !important;
    }

    .html-document table td {
      padding: 8px !important;
      color: #000 !important;
    }

    /* Ensure all nested elements in html-document stay black on white */
    .html-document * {
      color: #000 !important;
    }
  </style>
</head>
<body>
  <div id="appBanner" style="display:none;padding:8px 12px;background:#ffefef;color:#900;border:1px solid #f3caca;margin:8px 16px;border-radius:6px;"></div>
  <header class="header flex items-center justify-between px-6 py-4">
    <a href="./index.html" id="brand-link" class="flex items-center space-x-3 no-underline transition hover:opacity-80">
      <div class="logo bg-blue-600 text-white font-bold rounded-full w-8 h-8 flex items-center justify-center text-lg">B</div>
      <span class="brand text-lg font-semibold tracking-wide text-gray-900 dark:text-white">BRAG AI (LEGAL)</span>
    </a>
    <nav class="flex items-center space-x-4">
      <a href="./index.html" class="text-sm font-medium hover:underline">Home</a>
      <a href="./ingest.html" class="text-sm font-medium hover:underline">Ingest</a>
      <a href="./chat.html" class="text-sm font-medium hover:underline">Chat</a>
      <button onclick="__bragaiTheme.toggleTheme()" data-theme-toggle class="theme-toggle border rounded-xl px-3 py-1 text-sm flex items-center">
        &#127769; Dark
      </button>
    </nav>
  </header>

  <div class="app">
  <!-- Sidebar -->
  <aside class="sidebar">
    <div class="sb-head" style="border-top: 1px solid var(--border); border-bottom: none;">
      <button class="chat-btn primary" id="newChat" style="flex: 1;">+ New Chat</button>
      <button class="chat-btn" id="refreshChats" title="Refresh conversations">Refresh</button>
    </div>
    <div class="conv-list" id="convList"></div>
  </aside>

  <!-- Main chat area -->
  <main class="main">
    <div class="chat-header">
      <h2>Chat</h2>
    </div>
    <div class="chat" id="transcript"></div>
    <div class="chat-toolbar">
      <button id="attachDocBtn" type="button" class="btn">📎 Attach Document</button>
      <input
        id="ephemeralFileInput"
        type="file"
        accept=".pdf,.doc,.docx,.txt"
        style="display:none"
      />
      <span id="ephemeralStatus" class="muted"></span>
    </div>
    <div class="composer">
      <textarea id="input" placeholder="Ask anything about your documents..." rows="1"></textarea>
      <button class="chat-btn primary" id="send">Send</button>
    </div>
  </main>
  </div>

  <script type="module">
  import { API_BASE } from "./config.runtime.js?v=2025-10-13-dark-fix";

  const API_ROOT = (typeof API_BASE === 'string' && API_BASE.length) ? API_BASE : '';
  const API = `${API_ROOT}/api/v1/lawfirm`;
  let conversationId = localStorage.getItem('conversation_id') || null;
  const userId = localStorage.getItem('user_id') || 'anon';

  const banner = document.getElementById('appBanner');
  const convList = document.getElementById('convList');
  const transcript = document.getElementById('transcript');
  const input = document.getElementById('input');
  const sendBtn = document.getElementById('send');
  const attachBtn = document.getElementById('attachDocBtn');
  const fileInput = document.getElementById('ephemeralFileInput');
  const attachmentStatus = document.getElementById('ephemeralStatus');

  const ALLOWED_EPHEMERAL_EXTS = new Set(['pdf', 'doc', 'docx', 'txt']);
  const MAX_EPHEMERAL_MB = 25;
  let currentEphemeralAbortController = null;

  // ---- helpers (declare BEFORE usage everywhere) ----
  function showBanner(msg) {
    if (!banner) return;
    banner.textContent = msg;
    banner.style.display = 'block';
  }

  function truncate(text, max) {
    if (typeof text !== 'string' || !Number.isFinite(max) || max <= 0) return '';
    if (text.length <= max) return text;
    return text.slice(0, Math.max(0, max - 1)) + '…';
  }

  async function fetchWithTimeout(url, options = {}, timeoutMs = 12000) {
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), timeoutMs);
    try {
      return await fetch(url, { ...options, signal: controller.signal });
    } finally {
      clearTimeout(timer);
    }
  }

  attachBtn?.addEventListener('click', () => fileInput?.click());

  fileInput?.addEventListener('change', async (event) => {
    const file = event.target.files?.[0];
    if (!file) return;

    const ext = (file.name.split('.').pop() || '').toLowerCase();
    if (!ALLOWED_EPHEMERAL_EXTS.has(ext)) {
      alert('Only PDF, DOC, DOCX, or TXT files are allowed.');
      fileInput.value = '';
      return;
    }

    if (file.size > MAX_EPHEMERAL_MB * 1024 * 1024) {
      alert(`File too large. Max ${MAX_EPHEMERAL_MB} MB.`);
      fileInput.value = '';
      return;
    }

    try {
      if (!conversationId) {
        await newConversation();
      }
      if (!conversationId) throw new Error('conversationId missing.');

      if (attachmentStatus) attachmentStatus.textContent = 'Uploading…';
      if (attachBtn) attachBtn.disabled = true;

      await uploadEphemeralDoc({ file, conversationId, userId });
      setChatHasDoc(conversationId, true);
      renderAttachmentChip(file.name);
      fileInput.value = '';
    } catch (err) {
      const message = err instanceof Error ? err.message : String(err || '');
      if (message === 'Upload aborted safely.') {
        console.warn('[EPHEMERAL] Upload aborted before completion.');
      } else {
        console.error('[EPHEMERAL] Upload failed:', err);
        alert(message || 'Failed to attach document.');
        showBanner(message || 'Failed to attach document.');
        if (attachmentStatus) attachmentStatus.textContent = '';
      }
    } finally {
      if (attachBtn) attachBtn.disabled = false;
    }
  });

  function renderAttachmentChip(filename) {
    if (!attachmentStatus) return;
    attachmentStatus.innerHTML = '';

    const prefix = document.createElement('span');
    prefix.textContent = 'Attached: ';
    attachmentStatus.appendChild(prefix);

    const chip = document.createElement('span');
    chip.className = 'ephemeral-chip';
    chip.title = filename;

    const label = document.createElement('span');
    label.textContent = truncateFilename(filename);
    chip.appendChild(label);

    const removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.setAttribute('aria-label', 'Remove attachment');
    removeBtn.textContent = 'Remove';
    removeBtn.addEventListener('click', detachEphemeralDoc);
    chip.appendChild(removeBtn);

    attachmentStatus.appendChild(chip);
  }

  function truncateFilename(name, max = 28) {
    if (!name) return '';
    return truncate(name, max);
  }

  async function removeEphemeralDoc(conversationId) {
    if (!conversationId) return;

    if (currentEphemeralAbortController) {
      currentEphemeralAbortController.abort();
      currentEphemeralAbortController = null;
    }

    const response = await fetch(`${API}/ephemeral/${conversationId}`, {
      method: 'DELETE',
    });

    if (!response.ok && response.status !== 404) {
      let detail = '';
      try {
        const errJson = await response.json();
        detail = errJson?.detail || '';
      } catch (err) {
        detail = '';
      }
      throw new Error(detail || `Failed to remove ephemeral document (${response.status}).`);
    }

    setChatHasDoc(conversationId, false);
    console.log('[EPHEMERAL] Previous document context removed.');
    return response;
  }

  async function uploadEphemeralDoc({ file, conversationId, userId }) {
    if (!conversationId) throw new Error('conversationId missing.');

    await removeEphemeralDoc(conversationId);

    const form = new FormData();
    form.append('conversation_id', conversationId);
    form.append('user_id', userId);
    form.append('file', file);

    const controller = new AbortController();
    currentEphemeralAbortController = controller;
    const timeoutId = setTimeout(() => controller.abort(), 75000);
    try {
      const response = await fetch(`${API}/ephemeral/upload`, {
        method: 'POST',
        body: form,
        signal: controller.signal,
      });

      if (!response.ok) {
        let errText = '';
        try {
          errText = await response.text();
        } catch (err) {
          errText = '';
        }
        if (errText) {
          throw new Error(`Upload failed (${response.status}): ${errText}`);
        }
        throw new Error(`Upload failed (${response.status}). Check /api/v1/lawfirm/ephemeral/ping.`);
      }

      const data = await response.json();
      return data;
    } catch (error) {
      if (error.name === 'AbortError') {
        console.warn('[EPHEMERAL] Upload aborted safely.');
        throw new Error('Upload aborted safely.');
      }
      throw error instanceof Error ? error : new Error(String(error));
    } finally {
      clearTimeout(timeoutId);
      if (currentEphemeralAbortController === controller) {
        currentEphemeralAbortController = null;
      }
    }
  }

  async function detachEphemeralDoc() {
    if (!conversationId) return;
    if (!confirm('Detach and delete the ephemeral document for this chat?')) return;

    try {
      if (attachmentStatus) attachmentStatus.textContent = 'Removing…';
      if (attachBtn) attachBtn.disabled = true;

      await removeEphemeralDoc(conversationId);

      setChatHasDoc(conversationId, false);
      if (attachmentStatus) {
        attachmentStatus.textContent = 'Attachment removed.';
        setTimeout(() => {
          if (attachmentStatus.textContent === 'Attachment removed.') {
            attachmentStatus.textContent = '';
          }
        }, 1500);
      }
    } catch (err) {
      console.error('[EPHEMERAL] Detach failed:', err);
      alert(err?.message || 'Failed to detach document.');
      showBanner(err?.message || 'Failed to detach document.');
      if (attachmentStatus) attachmentStatus.textContent = '';
    } finally {
      if (attachBtn) attachBtn.disabled = false;
    }
  }

  (async () => {
    try {
      const r = await fetchWithTimeout(`${API_ROOT}/healthz`, {}, 6000);
      if (!r.ok) {
        showBanner(`Health check failed (${r.status}).`);
      }
    } catch (e) {
      showBanner(`Cannot reach API (${e?.message || 'unknown error'}).`);
    }
  })();

  const CHAT_STATE_KEY = 'chat_state_meta';
  let chatState = {};
  try {
    chatState = JSON.parse(localStorage.getItem(CHAT_STATE_KEY) || '{}');
  } catch (e) {
    console.warn('[CHAT-STATE] Failed to parse chat state cache, resetting.', e);
    chatState = {};
  }

  const TWEAK_TRIGGERS = [
    'tweak','revise','modify','simplify','edit','tone','change','update','add','remove','replace'
  ];

  function getChatHasDoc(id) {
    return !!(chatState[id] && chatState[id].hasDoc);
  }

  function setChatHasDoc(id, value) {
    if (!id) return;
    chatState[id] = { ...(chatState[id] || {}), hasDoc: !!value };
    localStorage.setItem(CHAT_STATE_KEY, JSON.stringify(chatState));
  }

  function clearChatState(id) {
    if (!id || !chatState[id]) return;
    delete chatState[id];
    localStorage.setItem(CHAT_STATE_KEY, JSON.stringify(chatState));
  }

  function ensureChatSubject(id, userInput) {
    if (!id) return;
    const currentSubject = getChatTitle(id);
    if (currentSubject && currentSubject.trim() && currentSubject.trim().toLowerCase() !== "new chat") {
      return;
    }

    const original = (userInput || "").trim();
    if (!original) {
      return;
    }

    const lower = original.toLowerCase();
    let subject = "New chat";
    if (lower.includes("legal notice")) subject = "Legal notice generation request";
    else if (lower.includes("suit")) subject = "Suit drafting request";
    else if (lower.includes("petition")) subject = "Petition drafting request";
    else if (lower.includes("application")) subject = "Application drafting request";
    else if (lower.includes("bail")) subject = "Bail application drafting request";
    else if (lower.includes("affidavit")) subject = "Affidavit preparation request";
    else subject = original.charAt(0).toUpperCase() + original.slice(1);

    updateSidebarTitle(id, subject);
    chatState[id] = { ...(chatState[id] || {}), subjectLocked: true };
    localStorage.setItem(CHAT_STATE_KEY, JSON.stringify(chatState));
  }

  // Helper to detect if text is HTML (starts with <html>, <div>, <!DOCTYPE, etc.)
  function isHtmlContent(text) {
    const trimmed = (text || '').trim();
    
    // Debug: log first 200 chars to see what we're getting
    console.log('[HTML-DETECT] First 200 chars:', trimmed.substring(0, 200));
    console.log('[HTML-DETECT] Starts with <:', trimmed.startsWith('<'));
    console.log('[HTML-DETECT] Contains </:', trimmed.includes('</'));
    console.log('[HTML-DETECT] Length:', trimmed.length);
    
    // Check for common HTML patterns that indicate document generation
    const isHtml = trimmed.startsWith('<!DOCTYPE') || 
           trimmed.startsWith('<html') || 
           trimmed.startsWith('<div>') ||
           trimmed.startsWith('<div ') ||
           trimmed.match(/^<p>/) ||
           trimmed.match(/^<ol>/) ||
           // More aggressive: if it starts with < and has HTML tags, treat as HTML
           (trimmed.startsWith('<') && (trimmed.includes('</p>') || trimmed.includes('</div>') || trimmed.includes('</ol>')) && trimmed.length > 100);
    
    console.log('[HTML-DETECT] Result:', isHtml);
    return isHtml;
  }

  function bubble(role, text, isMarkdown = false, referencedPages = null, documentName = null, responseType = null) {
    const div = document.createElement('div');
    div.className = 'bubble ' + (role === 'user' ? 'user' : 'assistant');
    
    const roleLabel = document.createElement('strong');
    roleLabel.textContent = role;
    div.appendChild(roleLabel);

    if (role === 'assistant' && isMarkdown) {
      const answerBox = document.createElement('div');
      answerBox.className = 'assistant-card answer-content';
      
      // Check if content is HTML (doc-gen output) or Markdown (QA output)
      const treatAsHtml = responseType === 'html' || isHtmlContent(text);
      if (treatAsHtml) {
        // Render HTML directly for document generation
        answerBox.className = 'assistant-card answer-content html-document';
        answerBox.innerHTML = text;
        console.log('[HTML-DOC] Rendering as HTML document');

        // --- Add Copy button for docgen responses ---
        const wrapper = document.createElement('div');
        wrapper.className = 'html-doc-wrapper';
        wrapper.style.position = 'relative';
        wrapper.appendChild(answerBox);

        // Create Copy button
        const copyBtn = document.createElement('button');
        copyBtn.textContent = 'Copy';
        copyBtn.className = 'copy-doc-btn';
        Object.assign(copyBtn.style, {
          position: 'absolute',
          top: '10px',
          right: '16px',
          padding: '4px 10px',
          fontSize: '0.8rem',
          border: '1px solid var(--border)',
          borderRadius: '6px',
          background: 'var(--brand)',
          color: '#fff',
          cursor: 'pointer',
          opacity: '0.9',
          transition: 'opacity 0.2s ease',
          zIndex: '10'
        });

        copyBtn.onmouseenter = () => (copyBtn.style.opacity = '1');
        copyBtn.onmouseleave = () => (copyBtn.style.opacity = '0.9');

        copyBtn.addEventListener('click', async () => {
          try {
            const docText = answerBox.innerText || answerBox.textContent;
            await navigator.clipboard.writeText(docText.trim());
            copyBtn.textContent = 'Copied!';
            copyBtn.style.background = 'var(--success, #16a34a)';
            setTimeout(() => {
              copyBtn.textContent = 'Copy';
              copyBtn.style.background = 'var(--brand)';
            }, 1500);
          } catch (err) {
            console.error('[COPY] Failed:', err);
            copyBtn.textContent = 'Error';
          }
        });

        wrapper.appendChild(copyBtn);
        div.appendChild(wrapper);
        console.log('[COPY-BUTTON] Added for docgen bubble');
      } else {
        // Parse as markdown for QA responses
        answerBox.innerHTML = marked.parse(text);
        console.log('[MARKDOWN] Rendering as markdown');
        div.appendChild(answerBox);
      }

      // Add metadata
      if (referencedPages || documentName) {
        const metaDiv = document.createElement('div');
        metaDiv.className = 'meta-row';
            const rows = [];
        if (referencedPages && referencedPages.length > 0) {
          rows.push(`Reference pages: ${referencedPages.join(', ')}`);
        }
        if (documentName) {
          rows.push(`Document: ${documentName}`);
        }
        metaDiv.textContent = rows.join(' | ');
            div.appendChild(metaDiv);
          }
        } else {
      const content = document.createElement('div');
      content.textContent = text;
      div.appendChild(content);
    }

    transcript.appendChild(div);
    transcript.scrollTop = transcript.scrollHeight;
  }

  /* --- Copy Button Styling Enhancements --- */
  const style = document.createElement('style');
  style.textContent = `
    .copy-doc-btn {
      background: var(--brand, #2563eb);
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 4px 10px;
      font-size: 0.8rem;
      cursor: pointer;
      opacity: 0.9;
      transition: background 0.2s ease, opacity 0.2s ease;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      z-index: 10;
    }
    .copy-doc-btn:hover {
      filter: brightness(1.05);
      opacity: 1;
    }
    .assistant-card.html-document {
      position: relative;
      z-index: 1;
      overflow: visible !important;
    }
    .html-doc-wrapper {
      position: relative;
    }
    .bubble.assistant {
      position: relative;
      overflow: visible !important;
    }
  `;
  document.head.appendChild(style);

  function escapeHtml(str) {
    return (str || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  async function listConversations() {
    try {
      const r = await fetch(`${API}/conversations?user_id=${encodeURIComponent(userId)}`);
      const data = await r.json();
      convList.innerHTML = '';
      
      if (data.length === 0) {
        const empty = document.createElement('div');
        empty.style.padding = '16px';
        empty.style.textAlign = 'center';
        empty.style.color = 'var(--muted)';
        empty.style.fontSize = '0.875rem';
        empty.textContent = 'No conversations yet';
        convList.appendChild(empty);
        return;
      }

      data.forEach(c => {
        const item = document.createElement('div');
        item.className = 'conv' + (c.id === conversationId ? ' active' : '');
        item.dataset.convId = c.id; // Add data attribute for easier selection
        if (getChatHasDoc(c.id)) {
          item.classList.add('has-doc');
        }
        
        const title = document.createElement('div');
        title.className = 'conv-title';
        // Use persisted title from localStorage if available
        title.textContent = getChatTitle(c.id);
        item.appendChild(title);

        const date = document.createElement('div');
        date.className = 'conv-date';
        const d = new Date(c.created_at);
        date.textContent = d.toLocaleDateString() + ' ' + d.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
        item.appendChild(date);

        // Delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-chat';
        deleteBtn.textContent = 'Delete';
        deleteBtn.title = 'Delete conversation';
        deleteBtn.onclick = async (e) => {
          e.stopPropagation();
          if (confirm('Delete this conversation?')) {
            await deleteConversation(c.id);
          }
        };
        item.appendChild(deleteBtn);

        item.onclick = async () => {
          conversationId = c.id;
          localStorage.setItem('conversation_id', conversationId);
          await loadMessages();
          await listConversations(); // Refresh to update active state
        };
        
        convList.appendChild(item);
      });
    } catch (e) {
      console.error('Failed to list conversations:', e);
    }
  }

  async function deleteConversation(convId) {
    try {
      await fetch(`${API}/conversations/${convId}`, {
        method: 'DELETE'
      });
      clearChatState(convId);
      
      // If we deleted the current conversation, clear it
      if (convId === conversationId) {
        conversationId = null;
        localStorage.removeItem('conversation_id');
        transcript.innerHTML = '';
        
        // Load first available conversation or create new one
        const r = await fetch(`${API}/conversations?user_id=${encodeURIComponent(userId)}`);
        const convs = await r.json();
        
        if (convs.length > 0) {
          conversationId = convs[0].id;
          localStorage.setItem('conversation_id', conversationId);
          await loadMessages();
        } else {
          await newConversation();
        }
      }
      
      await listConversations();
    } catch (e) {
      console.error('Failed to delete conversation:', e);
      alert('Failed to delete conversation. Please try again.');
    }
  }

  async function newConversation() {
    try {
      const r = await fetch(`${API}/conversations/new`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({user_id: userId})
      });
      const data = await r.json();
      conversationId = data.conversation_id;
      localStorage.setItem('conversation_id', conversationId);
      setChatHasDoc(conversationId, false);
      transcript.innerHTML = '';
      await listConversations();
    } catch (e) {
      console.error('Failed to create conversation:', e);
    }
  }

  async function loadMessages() {
    if (!conversationId) {
      await newConversation();
      return;
    }
    
    try {
      const r = await fetch(`${API}/conversations/${conversationId}/messages`);
      const data = await r.json();
      transcript.innerHTML = '';
      data.forEach(m => {
        // Check if message has markdown metadata (for assistant messages)
        const isMarkdown = m.role === 'assistant';
        const respType = (m?.metadata && m.metadata.response_type) || m?.response_type || null;
        const hasDocMeta = m?.metadata && Object.prototype.hasOwnProperty.call(m.metadata, 'has_doc') ? m.metadata.has_doc : undefined;
        if (typeof hasDocMeta === 'boolean') {
          setChatHasDoc(conversationId, hasDocMeta);
        } else if (respType === 'html') {
          setChatHasDoc(conversationId, true);
        }
        bubble(m.role, m.content, isMarkdown, null, null, respType);
      });
    } catch (e) {
      console.error('Failed to load messages:', e);
    }
  }

  document.getElementById('newChat').onclick = newConversation;
  document.getElementById('refreshChats').onclick = listConversations;

  document.getElementById('send').onclick = send;
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      send();
    }
  });

  // Streaming helper - displays text word by word
  async function streamResponse(bubbleDiv, fullText, responseType = null) {
    const contentDiv = bubbleDiv.querySelector('.answer-content') || bubbleDiv.querySelector('div:last-child');
    if (!contentDiv) return;

    // Check if content is HTML - if so, render immediately without streaming
    const treatAsHtml = responseType === 'html' || isHtmlContent(fullText);
    if (treatAsHtml) {
      contentDiv.className = 'assistant-card answer-content html-document';
      contentDiv.innerHTML = fullText;

      let wrapper = contentDiv.parentElement;
      if (!wrapper || !wrapper.classList.contains('html-doc-wrapper')) {
        wrapper = document.createElement('div');
        wrapper.className = 'html-doc-wrapper';
        wrapper.style.position = 'relative';
        contentDiv.replaceWith(wrapper);
        wrapper.appendChild(contentDiv);
      }

      let copyBtn = wrapper.querySelector('.copy-doc-btn');
      if (!copyBtn) {
        copyBtn = document.createElement('button');
        copyBtn.textContent = 'Copy';
        copyBtn.className = 'copy-doc-btn';
        copyBtn.style.position = 'absolute';
        copyBtn.style.top = '10px';
        copyBtn.style.right = '16px';
        copyBtn.style.padding = '4px 10px';
        copyBtn.style.fontSize = '0.8rem';
        copyBtn.style.border = '1px solid var(--border)';
        copyBtn.style.borderRadius = '6px';
        copyBtn.style.background = 'var(--brand)';
        copyBtn.style.color = '#fff';
        copyBtn.style.cursor = 'pointer';
        copyBtn.style.opacity = '0.9';
        copyBtn.style.transition = 'opacity 0.2s ease';
        copyBtn.style.zIndex = '10';

        copyBtn.onmouseenter = () => (copyBtn.style.opacity = '1');
        copyBtn.onmouseleave = () => (copyBtn.style.opacity = '0.9');

        copyBtn.addEventListener('click', async () => {
          try {
            const docText = contentDiv.innerText || contentDiv.textContent || '';
            await navigator.clipboard.writeText(docText.trim());
            copyBtn.textContent = 'Copied!';
            copyBtn.style.background = 'var(--success, #16a34a)';
            setTimeout(() => {
              copyBtn.textContent = 'Copy';
              copyBtn.style.background = 'var(--brand)';
            }, 1500);
          } catch (err) {
            console.error('[COPY] Failed during streaming:', err);
            copyBtn.textContent = 'Error';
          }
        });

        wrapper.appendChild(copyBtn);
        console.log('[COPY-BUTTON] Added during streaming');
      }

      transcript.scrollTop = transcript.scrollHeight;
      console.log('[HTML-DOC] Rendered HTML document in streaming');
      return;
    }

    // Stream markdown content word by word
    const words = fullText.split(' ');
    let displayedText = '';
    
    // Add cursor
    const cursor = document.createElement('span');
    cursor.className = 'streaming-cursor';
    contentDiv.appendChild(cursor);

    for (let i = 0; i < words.length; i++) {
      displayedText += (i > 0 ? ' ' : '') + words[i];
      
      // Update content - use innerHTML for markdown-like formatting
      contentDiv.innerHTML = displayedText.replace(/\n/g, '<br>');
      contentDiv.appendChild(cursor);
      
      // Smooth scroll
      transcript.scrollTop = transcript.scrollHeight;
      
      // Word-by-word delay (adjust speed here)
      await new Promise(resolve => setTimeout(resolve, 30));
    }
    
    // Remove cursor and render final markdown
    cursor.remove();
    contentDiv.innerHTML = marked.parse(fullText);
  }

  // --- Sidebar title helpers with localStorage persistence ---
  function normalizeTitleFromText(text) {
    if (!text) return "New Chat";
    const words = text.trim().replace(/\s+/g, ' ').split(' ').slice(0, 7).join(' ');
    const capped = words.charAt(0).toUpperCase() + words.slice(1);
    return capped.length > 40 ? capped.slice(0, 37) + 'ΓÇª' : capped;
  }
  
  function saveChatTitle(conversationId, title) {
    const map = JSON.parse(localStorage.getItem('chatTitles') || '{}');
    map[conversationId] = title;
    localStorage.setItem('chatTitles', JSON.stringify(map));
  }
  
  function getChatTitle(conversationId) {
    const map = JSON.parse(localStorage.getItem('chatTitles') || '{}');
    return map[conversationId] || "New Chat";
  }
  
  function updateSidebarTitle(conversationId, newTitle) {
    const item = document.querySelector(`[data-conv-id="${conversationId}"] .conv-title`);
    if (item) {
      if (item.textContent.trim() === "New Chat") {
        item.textContent = newTitle;
      }
    }
    saveChatTitle(conversationId, newTitle);
  }
  
  // Helper function to generate title from first user message (legacy support)
  function generateTitleFromMessage(text) {
    return normalizeTitleFromText(text);
  }
  
  // Update chat title in sidebar (only if it's "New Chat") - legacy support
  function updateChatTitleInSidebar(convId, newTitle) {
    updateSidebarTitle(convId, newTitle);
  }

  async function send() {
    const text = input.value.trim();
    if (!text) return;

    if (conversationId && getChatHasDoc(conversationId)) {
      const lower = text.toLowerCase();
      if (TWEAK_TRIGGERS.some(trigger => lower.includes(trigger))) {
        console.log('[DOC-TWEAK] Applying tweak to existing document context.');
      }
    }

    if (conversationId && getChatHasDoc(conversationId)) {
      const lower = text.toLowerCase();
      if (TWEAK_TRIGGERS.some(trigger => lower.includes(trigger))) {
        console.log('[DOC-TWEAK] Applying tweak to existing document context.');
      }
    }

    bubble('user', text);
    input.value = '';
    sendBtn.disabled = true;

    if (!conversationId) await newConversation();

    // Create assistant bubble with loading
    const assistantDiv = document.createElement('div');
    assistantDiv.className = 'bubble assistant';
    const roleLabel = document.createElement('strong');
    roleLabel.textContent = 'assistant';
    assistantDiv.appendChild(roleLabel);
    
    const contentDiv = document.createElement('div');
    contentDiv.className = 'assistant-card answer-content';
    contentDiv.innerHTML = '<div style="display: flex; align-items: center; gap: 8px;"><span class="loading"></span><span>Thinking...</span></div>';
    assistantDiv.appendChild(contentDiv);
    
    transcript.appendChild(assistantDiv);
    transcript.scrollTop = transcript.scrollHeight;

    try {
      const storedConversation = localStorage.getItem('conversation_id');
      if (storedConversation) {
        conversationId = storedConversation;
      }

      const body = {
        query: text,
        conversation_id: conversationId,
        user_id: userId
      };
      
      const r = await fetch(`${API}/query`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(body)
      });
      
      const data = await r.json();

      // Update conversation_id from response
      if (data?.metadata?.conversation_id) {
        conversationId = data.metadata.conversation_id;
        localStorage.setItem('conversation_id', conversationId);
      }

      // Clear loading and stream response
      const content = data?.answer || '[no answer]';
      contentDiv.innerHTML = '';
      
      const responseType = data?.metadata?.response_type || null;
      const hasDocMeta = data?.metadata?.has_doc;
      if (typeof hasDocMeta === 'boolean') {
        setChatHasDoc(conversationId, hasDocMeta);
      } else if (responseType === 'html') {
        setChatHasDoc(conversationId, true);
      }
      await streamResponse(assistantDiv, content, responseType);
      ensureChatSubject(conversationId, text);
      
      // Add metadata after streaming
      const pages = data?.metadata?.referenced_pages;
      const doc = data?.metadata?.document;
      const docType = data?.metadata?.doc_type;
      const references = Array.isArray(data?.metadata?.references) ? data.metadata.references.filter(Boolean) : [];
      
      if ((pages && pages.length) || doc || (docType && docType !== 'general') || references.length) {
        const metaDiv = document.createElement('div');
        metaDiv.className = 'meta-row';
        const rows = [];
        if (pages && pages.length > 0) {
          rows.push(`Reference pages: ${pages.join(', ')}`);
        }
        if (doc) {
          rows.push(`Document: ${doc}`);
        }
        if (docType && docType !== 'general') {
          rows.push(`Document type: ${docType.replace(/_/g, ' ')}`);
        }
        if (references.length > 0) {
          rows.push(`Referenced from: ${references.join(', ')}`);
        }
        metaDiv.textContent = rows.join(' | ');
        assistantDiv.appendChild(metaDiv);
      }
      
      // Refresh conversation list
      await listConversations();
    } catch (e) {
      console.error('Query error:', e);
      contentDiv.innerHTML = `Error: ${escapeHtml(e?.message || e)}`;
    } finally {
      sendBtn.disabled = false;
      input.focus();
    }
  }

  // Initialize
  (async function init() {
    try {
      console.log('[INIT] Starting initialization...');
      if (!conversationId) {
        console.log('[INIT] No conversation ID, creating new...');
        await newConversation();
      }
      console.log('[INIT] Loading conversations...');
      await listConversations();
      console.log('[INIT] Loading messages...');
      await loadMessages();
      console.log('[INIT] Initialization complete');
      input.focus();
    } catch (e) {
      console.error('[INIT] Initialization failed:', e);
      alert('Failed to initialize chat. Please refresh the page.');
    }
  })();

  // Auto-resize textarea
  input.addEventListener('input', function() {
    this.style.height = 'auto';
    this.style.height = Math.min(this.scrollHeight, 150) + 'px';
  });
  </script>

  <script>
    document.addEventListener('click', (event) => {
      const brandLink = event.target.closest('#brand-link');
      if (brandLink) {
        event.preventDefault();
        window.location.href = './index.html';
      }
    });
  </script>
  
</body>
</html>
