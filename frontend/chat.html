<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
  <meta http-equiv="Pragma" content="no-cache"/>
  <meta http-equiv="Expires" content="0"/>
  <title>BRAG AI â€” Chat</title>
  <link rel="stylesheet" href="./styles.css"/>
  <script src="./theme.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    /* Chat-specific overrides that work with theme.js */
    :root {
      --sidebar: #ffffff;
      --panel: #f8fafc;
      --chat-bg: #f3f7ff;
      --hover: #e5e7eb;
    }

    :root[data-theme="dark"] {
      --sidebar: #0f172a;
      --panel: #0b1220;
      --chat-bg: #0b1120;
      --hover: #1e293b;
    }

    body {
      margin: 0;
      background: var(--chat-bg);
      color: var(--text);
      font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
    }

    .app {
      display: flex;
      height: 100vh;
    }

    /* Sidebar */
    .sidebar {
      width: 280px;
      background: var(--sidebar);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .sb-head {
      padding: 14px;
      border-bottom: 1px solid var(--border);
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .sb-head .brand {
      flex: 1;
      font-weight: 600;
      font-size: 0.95rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .sb-head .brand img {
      width: 24px;
      height: 24px;
    }

    .chat-btn {
      background: var(--panel);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.875rem;
      white-space: nowrap;
      transition: all 0.2s;
    }

    .chat-btn:hover {
      border-color: var(--brand);
      background: var(--hover);
    }

    .chat-btn.primary {
      background: var(--brand);
      border-color: var(--brand);
      color: #fff;
      font-weight: 500;
    }

    .chat-btn.primary:hover {
      background: var(--brand-600);
      border-color: var(--brand-600);
    }

    .conv-list {
      overflow-y: auto;
      padding: 8px;
      flex: 1;
    }

    .conv {
      padding: 10px 12px;
      border-radius: 8px;
      margin: 4px 0;
      cursor: pointer;
      background: transparent;
      border: 1px solid transparent;
      transition: all 0.15s;
      font-size: 0.9rem;
      position: relative;
      display: flex;
      flex-direction: column;
    }

    .conv:hover {
      background: var(--hover);
      border-color: #213044;
    }

    .conv.active {
      background: var(--panel);
      border-color: var(--accent);
    }

    .conv-title {
      font-weight: 500;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      padding-right: 30px;
    }

    .conv-date {
      font-size: 0.75rem;
      color: var(--muted);
      margin-top: 4px;
    }

    .delete-chat {
      position: absolute;
      top: 10px;
      right: 8px;
      background: #dc2626;
      border: 1px solid #b91c1c;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.85rem;
      opacity: 0;
      transform: scale(0.8);
      transition: all 0.2s;
      z-index: 10;
    }

    .conv:hover .delete-chat {
      opacity: 1;
      transform: scale(1);
    }

    .delete-chat:hover {
      background: #b91c1c;
      border-color: #991b1b;
    }

    .streaming-cursor {
      display: inline-block;
      width: 2px;
      height: 1em;
      background: var(--brand);
      margin-left: 2px;
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0; }
    }

    /* Main content */
    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .chat-header {
      padding: 14px 20px;
      border-bottom: 1px solid var(--border);
      background: var(--sidebar);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .chat-header h2 {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
    }

    .chat {
      flex: 1;
      overflow-y: auto;
      padding: 20px 24px;
      background: var(--chat-bg);
    }

    .bubble {
      max-width: 800px;
      margin: 16px 0;
      padding: 16px 18px;
      border-radius: 12px;
      background: var(--panel);
      border: 1px solid var(--border);
      line-height: 1.6;
    }

    .bubble.user {
      background: var(--panel);
      margin-left: auto;
      max-width: 600px;
      border-left: 3px solid var(--brand);
    }

    .bubble.assistant {
      background: var(--panel);
      border-left: 3px solid var(--success);
    }

    .bubble strong {
      display: block;
      margin-bottom: 8px;
      color: var(--brand);
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .bubble.user strong {
      color: var(--brand-600);
    }

    .assistant-card h2,
    .assistant-card h3 {
      margin: 12px 0 8px;
    }

    .assistant-card p {
      margin: 8px 0;
      line-height: 1.6;
    }

    .assistant-card ul {
      margin: 8px 0 8px 18px;
    }

    .meta-row {
      margin: 8px 0 0;
      font-size: 0.85rem;
      opacity: 0.8;
      color: var(--muted);
    }

    .composer {
      display: flex;
      gap: 8px;
      padding: 14px 20px;
      border-top: 1px solid var(--border);
      background: var(--sidebar);
    }

    textarea {
      flex: 1;
      background: var(--panel);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      min-height: 48px;
      max-height: 150px;
      resize: vertical;
      font-family: inherit;
      font-size: 0.95rem;
    }

    textarea:focus {
      outline: none;
      border-color: var(--accent);
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: #374151;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #4b5563;
    }

    .loading {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid var(--border);
      border-top-color: var(--brand);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .streaming-cursor {
      background: var(--brand);
    }

    /* Styling for rendered HTML documents (doc-gen) */
    .html-document {
      background: white !important;
      color: #000 !important;
      padding: 40px !important;
      font-family: 'Times New Roman', Times, serif !important;
      line-height: 1.6 !important;
      max-width: 100% !important;
      border: 1px solid #ddd !important;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
    }

    /* Dark mode: keep document white (like a paper) */
    :root[data-theme="dark"] .html-document {
      background: white !important;
      color: #000 !important;
      border: 1px solid #555 !important;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3) !important;
    }

    .html-document p {
      margin: 12px 0 !important;
      text-align: justify !important;
      color: #000 !important;
    }

    .html-document ol {
      margin: 16px 0 !important;
      padding-left: 24px !important;
    }

    .html-document ol li {
      margin: 8px 0 !important;
      text-align: justify !important;
      color: #000 !important;
    }

    .html-document h1, .html-document h2, .html-document h3 {
      text-align: center !important;
      margin: 16px 0 !important;
      font-weight: bold !important;
      text-transform: uppercase !important;
      color: #000 !important;
    }

    .html-document table {
      margin: 16px auto !important;
      border-collapse: collapse !important;
    }

    .html-document table td {
      padding: 8px !important;
      color: #000 !important;
    }

    /* Ensure all nested elements in html-document stay black on white */
    .html-document * {
      color: #000 !important;
    }
  </style>
</head>
<body>
<div class="app">
  <!-- Sidebar -->
  <aside class="sidebar">
    <div class="sb-head">
      <a href="./index.html" class="brand" id="brand-link" style="text-decoration: none; color: var(--text);">
        <img src="./logo.svg" alt="BRAG AI"/>
        <span>BRAG AI</span>
      </a>
    </div>
    <div class="sb-head" style="border-top: 1px solid var(--border); border-bottom: none;">
      <button class="chat-btn primary" id="newChat" style="flex: 1;">+ New Chat</button>
      <button class="chat-btn" id="refreshChats" title="Refresh conversations">â†»</button>
    </div>
    <div class="conv-list" id="convList"></div>
  </aside>

  <!-- Main chat area -->
  <main class="main">
    <div class="chat-header">
      <h2>Chat</h2>
      <div style="display: flex; gap: 8px; align-items: center;">
        <a href="./index.html" class="chat-btn" style="text-decoration: none; display: inline-block;">Home</a>
        <a href="./ingest.html" class="chat-btn" style="text-decoration: none; display: inline-block;">Ingest</a>
        <button class="chat-btn" data-theme-toggle onclick="__bragaiTheme.toggleTheme()" style="border-color: var(--border);">ðŸŒ™ Dark</button>
      </div>
    </div>
    <div class="chat" id="transcript"></div>
    <div class="composer">
      <textarea id="input" placeholder="Ask anything about your documents..." rows="1"></textarea>
      <button class="chat-btn primary" id="send">Send</button>
    </div>
  </main>
  </div>

  <script type="module">
  import { API_BASE } from "./config.runtime.js?v=2025-10-13-dark-fix";

  const API = API_BASE + '/api/v1/lawfirm';
  let conversationId = localStorage.getItem('conversation_id') || null;
  const userId = localStorage.getItem('user_id') || 'anon';

  const convList = document.getElementById('convList');
  const transcript = document.getElementById('transcript');
  const input = document.getElementById('input');
  const sendBtn = document.getElementById('send');

  // Helper to detect if text is HTML (starts with <html>, <div>, <!DOCTYPE, etc.)
  function isHtmlContent(text) {
    const trimmed = (text || '').trim();
    
    // Debug: log first 200 chars to see what we're getting
    console.log('[HTML-DETECT] First 200 chars:', trimmed.substring(0, 200));
    console.log('[HTML-DETECT] Starts with <:', trimmed.startsWith('<'));
    console.log('[HTML-DETECT] Contains </:', trimmed.includes('</'));
    console.log('[HTML-DETECT] Length:', trimmed.length);
    
    // Check for common HTML patterns that indicate document generation
    const isHtml = trimmed.startsWith('<!DOCTYPE') || 
           trimmed.startsWith('<html') || 
           trimmed.startsWith('<div>') ||
           trimmed.startsWith('<div ') ||
           trimmed.match(/^<p>/) ||
           trimmed.match(/^<ol>/) ||
           // More aggressive: if it starts with < and has HTML tags, treat as HTML
           (trimmed.startsWith('<') && (trimmed.includes('</p>') || trimmed.includes('</div>') || trimmed.includes('</ol>')) && trimmed.length > 100);
    
    console.log('[HTML-DETECT] Result:', isHtml);
    return isHtml;
  }

  function bubble(role, text, isMarkdown = false, referencedPages = null, documentName = null) {
    const div = document.createElement('div');
    div.className = 'bubble ' + (role === 'user' ? 'user' : 'assistant');
    
    const roleLabel = document.createElement('strong');
    roleLabel.textContent = role;
    div.appendChild(roleLabel);

    if (role === 'assistant' && isMarkdown) {
      const answerBox = document.createElement('div');
      answerBox.className = 'assistant-card answer-content';
      
      // Check if content is HTML (doc-gen output) or Markdown (QA output)
      if (isHtmlContent(text)) {
        // Render HTML directly for document generation
        answerBox.className = 'assistant-card answer-content html-document';
        answerBox.innerHTML = text;
        console.log('[HTML-DOC] Rendering as HTML document');
      } else {
        // Parse as markdown for QA responses
        answerBox.innerHTML = marked.parse(text);
        console.log('[MARKDOWN] Rendering as markdown');
      }
      
      div.appendChild(answerBox);

      // Add metadata
      if (referencedPages || documentName) {
        const metaDiv = document.createElement('div');
        metaDiv.className = 'meta-row';
            const rows = [];
        if (referencedPages && referencedPages.length > 0) {
          rows.push(`Reference pages: ${referencedPages.join(', ')}`);
        }
        if (documentName) {
          rows.push(`Document: ${documentName}`);
        }
        metaDiv.textContent = rows.join(' | ');
            div.appendChild(metaDiv);
          }
        } else {
      const content = document.createElement('div');
      content.textContent = text;
      div.appendChild(content);
    }

    transcript.appendChild(div);
    transcript.scrollTop = transcript.scrollHeight;
  }

  function escapeHtml(str) {
    return (str || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  async function listConversations() {
    try {
      const r = await fetch(`${API}/conversations?user_id=${encodeURIComponent(userId)}`);
      const data = await r.json();
      convList.innerHTML = '';
      
      if (data.length === 0) {
        const empty = document.createElement('div');
        empty.style.padding = '16px';
        empty.style.textAlign = 'center';
        empty.style.color = 'var(--muted)';
        empty.style.fontSize = '0.875rem';
        empty.textContent = 'No conversations yet';
        convList.appendChild(empty);
        return;
      }

      data.forEach(c => {
        const item = document.createElement('div');
        item.className = 'conv' + (c.id === conversationId ? ' active' : '');
        item.dataset.convId = c.id; // Add data attribute for easier selection
        
        const title = document.createElement('div');
        title.className = 'conv-title';
        // Use persisted title from localStorage if available
        title.textContent = getChatTitle(c.id);
        item.appendChild(title);

        const date = document.createElement('div');
        date.className = 'conv-date';
        const d = new Date(c.created_at);
        date.textContent = d.toLocaleDateString() + ' ' + d.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
        item.appendChild(date);

        // Delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-chat';
        deleteBtn.innerHTML = 'ðŸ—‘ï¸';
        deleteBtn.title = 'Delete conversation';
        deleteBtn.onclick = async (e) => {
          e.stopPropagation();
          if (confirm('Delete this conversation?')) {
            await deleteConversation(c.id);
          }
        };
        item.appendChild(deleteBtn);

        item.onclick = async () => {
          conversationId = c.id;
          localStorage.setItem('conversation_id', conversationId);
          await loadMessages();
          await listConversations(); // Refresh to update active state
        };
        
        convList.appendChild(item);
      });
    } catch (e) {
      console.error('Failed to list conversations:', e);
    }
  }

  async function deleteConversation(convId) {
    try {
      await fetch(`${API}/conversations/${convId}`, {
        method: 'DELETE'
      });
      
      // If we deleted the current conversation, clear it
      if (convId === conversationId) {
        conversationId = null;
        localStorage.removeItem('conversation_id');
        transcript.innerHTML = '';
        
        // Load first available conversation or create new one
        const r = await fetch(`${API}/conversations?user_id=${encodeURIComponent(userId)}`);
        const convs = await r.json();
        
        if (convs.length > 0) {
          conversationId = convs[0].id;
          localStorage.setItem('conversation_id', conversationId);
          await loadMessages();
        } else {
          await newConversation();
        }
      }
      
      await listConversations();
    } catch (e) {
      console.error('Failed to delete conversation:', e);
      alert('Failed to delete conversation. Please try again.');
    }
  }

  async function newConversation() {
    try {
      const r = await fetch(`${API}/conversations/new`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({user_id: userId})
      });
      const data = await r.json();
      conversationId = data.conversation_id;
      localStorage.setItem('conversation_id', conversationId);
      transcript.innerHTML = '';
      await listConversations();
    } catch (e) {
      console.error('Failed to create conversation:', e);
    }
  }

  async function loadMessages() {
    if (!conversationId) {
      await newConversation();
      return;
    }
    
    try {
      const r = await fetch(`${API}/conversations/${conversationId}/messages`);
      const data = await r.json();
      transcript.innerHTML = '';
      data.forEach(m => {
        // Check if message has markdown metadata (for assistant messages)
        const isMarkdown = m.role === 'assistant';
        bubble(m.role, m.content, isMarkdown);
      });
    } catch (e) {
      console.error('Failed to load messages:', e);
    }
  }

  document.getElementById('newChat').onclick = newConversation;
  document.getElementById('refreshChats').onclick = listConversations;

  document.getElementById('send').onclick = send;
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      send();
    }
  });

  // Streaming helper - displays text word by word
  async function streamResponse(bubbleDiv, fullText) {
    const contentDiv = bubbleDiv.querySelector('.answer-content') || bubbleDiv.querySelector('div:last-child');
    if (!contentDiv) return;

    // Check if content is HTML - if so, render immediately without streaming
    if (isHtmlContent(fullText)) {
      contentDiv.className = 'assistant-card answer-content html-document';
      contentDiv.innerHTML = fullText;
      transcript.scrollTop = transcript.scrollHeight;
      console.log('[HTML-DOC] Rendered HTML document in streaming');
      return;
    }

    // Stream markdown content word by word
    const words = fullText.split(' ');
    let displayedText = '';
    
    // Add cursor
    const cursor = document.createElement('span');
    cursor.className = 'streaming-cursor';
    contentDiv.appendChild(cursor);

    for (let i = 0; i < words.length; i++) {
      displayedText += (i > 0 ? ' ' : '') + words[i];
      
      // Update content - use innerHTML for markdown-like formatting
      contentDiv.innerHTML = displayedText.replace(/\n/g, '<br>');
      contentDiv.appendChild(cursor);
      
      // Smooth scroll
      transcript.scrollTop = transcript.scrollHeight;
      
      // Word-by-word delay (adjust speed here)
      await new Promise(resolve => setTimeout(resolve, 30));
    }
    
    // Remove cursor and render final markdown
    cursor.remove();
    contentDiv.innerHTML = marked.parse(fullText);
  }

  // --- Sidebar title helpers with localStorage persistence ---
  function normalizeTitleFromText(text) {
    if (!text) return "New Chat";
    const words = text.trim().replace(/\s+/g, ' ').split(' ').slice(0, 7).join(' ');
    const capped = words.charAt(0).toUpperCase() + words.slice(1);
    return capped.length > 40 ? capped.slice(0, 37) + 'â€¦' : capped;
  }
  
  function saveChatTitle(conversationId, title) {
    const map = JSON.parse(localStorage.getItem('chatTitles') || '{}');
    map[conversationId] = title;
    localStorage.setItem('chatTitles', JSON.stringify(map));
  }
  
  function getChatTitle(conversationId) {
    const map = JSON.parse(localStorage.getItem('chatTitles') || '{}');
    return map[conversationId] || "New Chat";
  }
  
  function updateSidebarTitle(conversationId, newTitle) {
    const item = document.querySelector(`[data-conv-id="${conversationId}"] .conv-title`);
    if (item) {
      if (item.textContent.trim() === "New Chat") {
        item.textContent = newTitle;
      }
    }
    saveChatTitle(conversationId, newTitle);
  }
  
  // Helper function to generate title from first user message (legacy support)
  function generateTitleFromMessage(text) {
    return normalizeTitleFromText(text);
  }
  
  // Update chat title in sidebar (only if it's "New Chat") - legacy support
  function updateChatTitleInSidebar(convId, newTitle) {
    updateSidebarTitle(convId, newTitle);
  }

  async function send() {
    const text = input.value.trim();
    if (!text) return;
    
    bubble('user', text);
    input.value = '';
    sendBtn.disabled = true;

    if (!conversationId) await newConversation();

    // Auto-update chat title on first message (before API call for instant feedback)
    const newTitle = normalizeTitleFromText(text);
    updateSidebarTitle(conversationId, newTitle);

    // Create assistant bubble with loading
    const assistantDiv = document.createElement('div');
    assistantDiv.className = 'bubble assistant';
    const roleLabel = document.createElement('strong');
    roleLabel.textContent = 'assistant';
    assistantDiv.appendChild(roleLabel);
    
    const contentDiv = document.createElement('div');
    contentDiv.className = 'assistant-card answer-content';
    contentDiv.innerHTML = '<div style="display: flex; align-items: center; gap: 8px;"><span class="loading"></span><span>Thinking...</span></div>';
    assistantDiv.appendChild(contentDiv);
    
    transcript.appendChild(assistantDiv);
    transcript.scrollTop = transcript.scrollHeight;

    try {
      const body = {
        query: text,
        conversation_id: conversationId,
        user_id: userId
      };
      
      const r = await fetch(`${API}/query`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(body)
      });
      
      const data = await r.json();

      // Update conversation_id from response
      if (data?.metadata?.conversation_id) {
        conversationId = data.metadata.conversation_id;
        localStorage.setItem('conversation_id', conversationId);
      }

      // Clear loading and stream response
      const content = data?.answer || '[no answer]';
      contentDiv.innerHTML = '';
      
      await streamResponse(assistantDiv, content);
      
      // Add metadata after streaming
      const pages = data?.metadata?.referenced_pages;
      const doc = data?.metadata?.document;
      const docType = data?.metadata?.doc_type;
      const references = Array.isArray(data?.metadata?.references) ? data.metadata.references.filter(Boolean) : [];
      
      if ((pages && pages.length) || doc || (docType && docType !== 'general') || references.length) {
        const metaDiv = document.createElement('div');
        metaDiv.className = 'meta-row';
        const rows = [];
        if (pages && pages.length > 0) {
          rows.push(`Reference pages: ${pages.join(', ')}`);
        }
        if (doc) {
          rows.push(`Document: ${doc}`);
        }
        if (docType && docType !== 'general') {
          rows.push(`Document type: ${docType.replace(/_/g, ' ')}`);
        }
        if (references.length > 0) {
          rows.push(`Referenced from: ${references.join(', ')}`);
        }
        metaDiv.textContent = rows.join(' | ');
        assistantDiv.appendChild(metaDiv);
      }
      
      // Refresh conversation list
      await listConversations();
    } catch (e) {
      console.error('Query error:', e);
      contentDiv.innerHTML = `Error: ${escapeHtml(e?.message || e)}`;
    } finally {
      sendBtn.disabled = false;
      input.focus();
    }
  }

  // Initialize
  (async function init() {
    try {
      console.log('[INIT] Starting initialization...');
      if (!conversationId) {
        console.log('[INIT] No conversation ID, creating new...');
        await newConversation();
      }
      console.log('[INIT] Loading conversations...');
      await listConversations();
      console.log('[INIT] Loading messages...');
      await loadMessages();
      console.log('[INIT] Initialization complete');
      input.focus();
    } catch (e) {
      console.error('[INIT] Initialization failed:', e);
      alert('Failed to initialize chat. Please refresh the page.');
    }
  })();

  // Auto-resize textarea
  input.addEventListener('input', function() {
    this.style.height = 'auto';
    this.style.height = Math.min(this.scrollHeight, 150) + 'px';
  });
  </script>
  
  <script>
    // Ensure brand logo click navigates home
    document.getElementById('brand-link').addEventListener('click', (e) => {
      e.preventDefault(); 
      window.location.href = './index.html';
    });
  </script>
</body>
</html>
