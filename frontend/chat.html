<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
  <meta http-equiv="Pragma" content="no-cache"/>
  <meta http-equiv="Expires" content="0"/>
  <title>BRAG AI Î“Ã‡Ã¶ Chat</title>
  <link rel="stylesheet" href="./styles.css?v=1.1.3"/>
  <script src="./theme.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    /* Chat-specific overrides that work with theme.js */
    :root {
      --sidebar: #ffffff;
      --panel: #f8fafc;
      --chat-bg: #f3f7ff;
      --hover: #e5e7eb;
    }

    :root[data-theme="dark"] {
      --sidebar: #0f172a;
      --panel: #0b1220;
      --chat-bg: #0b1120;
      --hover: #1e293b;
    }

    body {
      margin: 0;
      background: var(--chat-bg);
      color: var(--text);
      font-family: Inter, system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      overflow: hidden;
    }

    .app {
      display: flex;
      flex: 1;
      min-height: 0;
    }

    /* Sidebar */
    .sidebar {
      width: 280px;
      background: var(--sidebar);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .sb-head {
      padding: 14px;
      border-bottom: 1px solid var(--border);
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .sb-head .brand {
      flex: 1;
      font-weight: 600;
      font-size: 0.95rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .sb-head .brand img {
      width: 24px;
      height: 24px;
    }

    .chat-btn {
      background: var(--panel);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.875rem;
      white-space: nowrap;
      transition: all 0.2s;
    }

    .chat-btn:hover {
      border-color: var(--brand);
      background: var(--hover);
    }

    .chat-btn.primary {
      background: var(--brand);
      border-color: var(--brand);
      color: #fff;
      font-weight: 500;
    }

    .chat-btn.primary:hover {
      background: var(--brand-600);
      border-color: var(--brand-600);
    }

    .conv-list {
      overflow-y: auto;
      padding: 8px;
      flex: 1;
    }

    .conv {
      padding: 10px 12px;
      border-radius: 8px;
      margin: 4px 0;
      cursor: pointer;
      background: transparent;
      border: 1px solid transparent;
      transition: all 0.15s;
      font-size: 0.9rem;
      position: relative;
      display: flex;
      flex-direction: column;
    }

    .conv:hover {
      background: var(--hover);
      border-color: #213044;
    }

    .conv.active {
      background: var(--panel);
      border-color: var(--accent);
    }

    .conv.has-doc::after {
      content: "DOC";
      position: absolute;
      top: 6px;
      right: 8px;
      font-size: 0.65rem;
      font-weight: 600;
      color: var(--brand);
      letter-spacing: 0.05em;
    }

    .conv-title {
      font-weight: 500;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      padding-right: 30px;
    }

    .conv-date {
      font-size: 0.75rem;
      color: var(--muted);
      margin-top: 4px;
    }

    .delete-chat {
      position: absolute;
      top: 10px;
      right: 8px;
      background: #dc2626;
      border: 1px solid #b91c1c;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.85rem;
      opacity: 0;
      transform: scale(0.8);
      transition: all 0.2s;
      z-index: 10;
    }

    .conv:hover .delete-chat {
      opacity: 1;
      transform: scale(1);
    }

    .delete-chat:hover {
      background: #b91c1c;
      border-color: #991b1b;
    }

    .streaming-cursor {
      display: inline-block;
      width: 2px;
      height: 1em;
      background: var(--brand);
      margin-left: 2px;
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0; }
    }

    /* Main content */
    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .chat-header {
      padding: 14px 20px;
      border-bottom: 1px solid var(--border);
      background: var(--sidebar);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .chat-header h2 {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
    }

    .chat {
      flex: 1;
      overflow-y: auto;
      padding: 20px 24px;
      background: var(--chat-bg);
    }

    .bubble {
      max-width: 800px;
      margin: 16px 0;
      padding: 16px 18px;
      border-radius: 12px;
      background: var(--panel);
      border: 1px solid var(--border);
      line-height: 1.6;
    }

    .bubble.user {
      background: var(--panel);
      margin-left: auto;
      max-width: 600px;
      border-left: 3px solid var(--brand);
    }

    .bubble.assistant {
      background: var(--panel);
      border-left: 3px solid var(--success);
    }

    .bubble strong {
      display: block;
      margin-bottom: 8px;
      color: var(--brand);
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .bubble.user strong {
      color: var(--brand-600);
    }

    .assistant-card h2,
    .assistant-card h3 {
      margin: 12px 0 8px;
    }

    .assistant-card p {
      margin: 8px 0;
      line-height: 1.6;
    }

    .assistant-card ul {
      margin: 8px 0 8px 18px;
    }

    .meta-row {
      margin: 8px 0 0;
      font-size: 0.85rem;
      opacity: 0.8;
      color: var(--muted);
    }

    .composer {
      display: flex;
      gap: 8px;
      padding: 14px 20px;
      border-top: 1px solid var(--border);
      background: var(--sidebar);
    }

    .chat-toolbar {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 20px;
      border-top: 1px solid var(--border);
      border-bottom: 1px solid var(--border);
      background: var(--sidebar);
    }

    .chat-toolbar .btn {
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background 0.2s, border 0.2s;
    }

    .chat-toolbar .btn:hover {
      background: var(--hover);
      border-color: var(--brand);
    }

    .chat-toolbar .btn[disabled] {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .chat-toolbar .muted {
      color: #6b7280;
      font-size: 0.75rem;
    }

    .attachment-context-banner {
      display: flex;
      align-items: center;
      gap: 6px;
      margin: 4px 20px 0;
      font-size: 0.75rem;
      color: var(--muted);
    }

    #attachmentSlot {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      min-height: 18px;
      font-size: 0.8rem;
    }

    /* --- File chip polish (bubble) --- */
    .file-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 9999px;
      background: #f3f4f6;
      color: #111827;
      border: 1px solid #e5e7eb;
      font-size: 12px;
      line-height: 1;
      white-space: nowrap;
    }

    :root[data-theme="dark"] .file-chip {
      background: #111827;
      color: #e5e7eb;
      border-color: #374151;
    }

    .file-chip .clip-icon {
      width: 14px;
      height: 14px;
      opacity: 0.75;
      flex: 0 0 auto;
    }

    .file-chip .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .composer-attachment-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .composer-attachment-chip button {
      border: none;
      background: transparent;
      color: inherit;
      cursor: pointer;
      font-size: 0.85rem;
      line-height: 1;
      padding: 0 2px;
    }

    .composer-attachment-chip button:hover {
      opacity: 0.7;
    }

    .attachment-context-banner .attachment-context-name {
      font-weight: 600;
    }

    .attachment-context-banner button {
      border: none;
      background: transparent;
      padding: 0;
      color: var(--brand);
      cursor: pointer;
      font-size: 0.75rem;
      text-decoration: underline;
    }

    .ephemeral-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border-radius: 12px;
      background: #f1f5f9;
      font-size: 0.75rem;
    }

    :root[data-theme="dark"] .ephemeral-chip {
      background: #1e293b;
      color: #cbd5f5;
    }
    .bubble-attachment-container {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
    }

    .bubble-attachment-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      margin-top: 8px;
    }

    .ephemeral-chip button {
      border: none;
      background: transparent;
      cursor: pointer;
      font-size: 0.8rem;
      color: inherit;
    }

    .ephemeral-chip button:hover {
      opacity: 0.7;
    }

    textarea {
      flex: 1;
      background: var(--panel);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      min-height: 48px;
      max-height: 150px;
      resize: vertical;
      font-family: inherit;
      font-size: 0.95rem;
    }

    textarea:focus {
      outline: none;
      border-color: var(--accent);
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: #374151;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #4b5563;
    }

    .loading {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid var(--border);
      border-top-color: var(--brand);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .streaming-cursor {
      background: var(--brand);
    }

    /* Styling for rendered HTML documents (doc-gen) */
    .html-document {
      background: white !important;
      color: #000 !important;
      padding: 40px !important;
      font-family: 'Times New Roman', Times, serif !important;
      line-height: 1.6 !important;
      max-width: 100% !important;
      border: 1px solid #ddd !important;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
    }

    /* Dark mode: keep document white (like a paper) */
    :root[data-theme="dark"] .html-document {
      background: white !important;
      color: #000 !important;
      border: 1px solid #555 !important;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3) !important;
    }

    .html-document p {
      margin: 12px 0 !important;
      text-align: justify !important;
      color: #000 !important;
    }

    .html-document ol {
      margin: 16px 0 !important;
      padding-left: 24px !important;
    }

    .html-document ol li {
      margin: 8px 0 !important;
      text-align: justify !important;
      color: #000 !important;
    }

    .html-document h1, .html-document h2, .html-document h3 {
      text-align: center !important;
      margin: 16px 0 !important;
      font-weight: bold !important;
      text-transform: uppercase !important;
      color: #000 !important;
    }

    .html-document table {
      margin: 16px auto !important;
      border-collapse: collapse !important;
    }

    .html-document table td {
      padding: 8px !important;
      color: #000 !important;
    }

    /* Ensure all nested elements in html-document stay black on white */
    .html-document * {
      color: #000 !important;
    }
  </style>
</head>
<body>
  <div id="appBanner" style="display:none;padding:8px 12px;background:#ffefef;color:#900;border:1px solid #f3caca;margin:8px 16px;border-radius:6px;"></div>
  <header class="header flex items-center justify-between px-6 py-4">
    <a href="./index.html" id="brand-link" class="flex items-center space-x-3 no-underline transition hover:opacity-80">
      <div class="logo bg-blue-600 text-white font-bold rounded-full w-8 h-8 flex items-center justify-center text-lg">B</div>
      <span class="brand text-lg font-semibold tracking-wide text-gray-900 dark:text-white">BRAG AI (LEGAL)</span>
    </a>
    <nav class="flex items-center space-x-4">
      <a href="./index.html" class="text-sm font-medium hover:underline">Home</a>
      <a href="./ingest.html" class="text-sm font-medium hover:underline">Ingest</a>
      <a href="./chat.html" class="text-sm font-medium hover:underline">Chat</a>
      <button onclick="__bragaiTheme.toggleTheme()" data-theme-toggle class="theme-toggle border rounded-xl px-3 py-1 text-sm flex items-center">
        &#127769; Dark
      </button>
    </nav>
  </header>

  <div class="app">
  <!-- Sidebar -->
  <aside class="sidebar">
    <div class="sb-head" style="border-top: 1px solid var(--border); border-bottom: none;">
      <button class="chat-btn primary" id="newChat" style="flex: 1;">+ New Chat</button>
      <button class="chat-btn" id="refreshChats" title="Refresh conversations">Refresh</button>
    </div>
    <div class="conv-list" id="convList"></div>
  </aside>

  <!-- Main chat area -->
  <main class="main">
    <div class="chat-header">
      <h2>Chat</h2>
    </div>
    <div class="chat" id="transcript"></div>
    <div class="chat-toolbar">
      <button id="attachDocBtn" type="button" class="btn">ðŸ“Ž Attach Document</button>
      <input
        id="ephemeralFileInput"
        type="file"
        multiple
        accept=".pdf,.doc,.docx,.txt"
        style="display:none"
      />
      <div id="attachmentSlot" class="muted"></div>
    </div>
    <div id="attachmentContextBanner" class="attachment-context-banner" style="display:none">
      <span>Using attached document(s)</span>
      <span id="attachmentContextName" class="attachment-context-name"></span>
      <span id="attachmentContextSeparator" aria-hidden="true">-</span>
      <button id="attachmentContextRemove" type="button">Remove</button>
    </div>
    <div class="composer">
      <textarea id="input" placeholder="Ask anything about your documents..." rows="1"></textarea>
      <button class="chat-btn primary" id="send">Send</button>
    </div>
  </main>
  </div>

  <script type="module">
  import { API_BASE } from "./config.runtime.js?v=2025-10-13-dark-fix";

  const API_ROOT = (typeof API_BASE === 'string' && API_BASE.length) ? API_BASE : '';
  const API = `${API_ROOT}/api/v1/lawfirm`;
  const CLIP_SVG = `
    <svg class="clip-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor"
         stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
      <path d="M21.44 11.05 12 20.5a6 6 0 1 1-8.49-8.49l9.9-9.9a4 4 0 0 1 5.66 5.66L8.46 18.38a2 2 0 1 1-2.83-2.83l8.49-8.49"/>
    </svg>`;
  let conversationId = localStorage.getItem('conversation_id') || null;
  const userId = localStorage.getItem('user_id') || 'anon';

  const banner = document.getElementById('appBanner');
  const convList = document.getElementById('convList');
  const transcript = document.getElementById('transcript');
  const input = document.getElementById('input');
  const sendBtn = document.getElementById('send');
  const attachBtn = document.getElementById('attachDocBtn');
  const fileInput = document.getElementById('ephemeralFileInput');
  const attachmentSlot = document.getElementById('attachmentSlot');
  const attachmentContextBanner = document.getElementById('attachmentContextBanner');
  const attachmentContextName = document.getElementById('attachmentContextName');
  const attachmentContextSeparator = document.getElementById('attachmentContextSeparator');
  const attachmentContextRemove = document.getElementById('attachmentContextRemove');

  const ALLOWED_EPHEMERAL_EXTS = new Set(['pdf', 'doc', 'docx', 'txt']);
  const MAX_EPHEMERAL_MB = 25;
  let inflightAttachmentController = null;
  const ATTACHMENT_CACHE_KEY = 'chat_ephemeral_attachments';
  let attachmentCache = {};
  try {
    attachmentCache = JSON.parse(localStorage.getItem(ATTACHMENT_CACHE_KEY) || '{}') || {};
  } catch (err) {
    console.warn('[ATTACHMENTS] Failed to parse attachment cache, resetting.', err);
    attachmentCache = {};
  }
  let ephemeralAttachments = [];
  let attachmentPinnedToMessage = false;

  if (attachmentContextRemove) {
    attachmentContextRemove.addEventListener('click', detachEphemeralDoc);
  }

  // ---- helpers (declare BEFORE usage everywhere) ----
  function showBanner(msg) {
    if (!banner) return;
    banner.textContent = msg;
    banner.style.display = 'block';
  }

  function truncate(text, max) {
    if (typeof text !== 'string' || !Number.isFinite(max) || max <= 0) return '';
    if (text.length <= max) return text;
    return text.slice(0, Math.max(0, max - 1)) + '...';
  }

  async function fetchWithTimeout(url, options = {}, timeoutMs = 12000) {
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), timeoutMs);
    try {
      return await fetch(url, { ...options, signal: controller.signal });
    } finally {
      clearTimeout(timer);
    }
  }

  attachBtn?.addEventListener('click', () => fileInput?.click());

  fileInput?.addEventListener('change', async (event) => {
    const files = Array.from(event.target.files || []);
    if (!files.length) return;

    try {
      if (!conversationId) {
        await newConversation();
      }
      if (!conversationId) {
        throw new Error('conversationId missing.');
      }

      const validFiles = files.filter(file => {
        const ext = (file.name.split('.').pop() || '').toLowerCase();
        if (!ALLOWED_EPHEMERAL_EXTS.has(ext)) {
          alert(`"${file.name}" is not an allowed file type (PDF, DOC, DOCX, TXT).`);
          return false;
        }
        if (file.size > MAX_EPHEMERAL_MB * 1024 * 1024) {
          alert(`"${file.name}" exceeds the ${MAX_EPHEMERAL_MB} MB limit.`);
          return false;
        }
        return true;
      });
      if (!validFiles.length) {
        fileInput.value = '';
        return;
      }

      if (attachmentSlot) {
        attachmentSlot.textContent = 'Uploading...';
      }
      hideAttachmentContextBanner();

      if (inflightAttachmentController) {
        inflightAttachmentController.abort();
      }
      inflightAttachmentController = new AbortController();

      if (attachBtn) attachBtn.disabled = true;

      try {
        const staleDocIds = ephemeralAttachments.filter(att => !att.pinned && att.doc_id).map(att => att.doc_id);
        const data = await uploadEphemeral(validFiles, { mode: 'replace', remove: staleDocIds, signal: inflightAttachmentController.signal });
        const uploadedFiles = Array.isArray(data?.files) ? data.files : [];
        const responseMode = typeof data?.mode === 'string' ? data.mode.toLowerCase() : 'replace';

        let nextAttachments = ephemeralAttachments.slice();
        if (responseMode === 'replace') {
          nextAttachments = nextAttachments.filter(att => att.pinned);
        }

        for (const file of uploadedFiles) {
          const docId = (file && file.doc_id) ? String(file.doc_id) : '';
          if (!docId) {
            continue;
          }
          const fileName = file?.file_name || file?.name || 'Document';
          nextAttachments.push({
            doc_id: docId,
            name: fileName,
            pinned: false,
          });
        }

        ephemeralAttachments = nextAttachments;
        attachmentPinnedToMessage = ephemeralAttachments.length > 0 && !ephemeralAttachments.some(att => !att.pinned);
        renderAttachmentChips();
        persistAttachments();
        updateContextBanner();
        syncChatHasDocState();
      } catch (err) {
        if (err?.name === 'AbortError') {
          return;
        }
        console.error('[EPHEMERAL] Upload failed:', err);
        const message = err instanceof Error ? err.message : String(err || '');
        alert(message || 'Failed to attach documents.');
        showBanner(message || 'Failed to attach documents.');
      } finally {
        inflightAttachmentController = null;
        if (attachmentSlot) {
          renderAttachmentChips();
        }
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : String(err || '');
      alert(message || 'Failed to attach documents.');
      console.error('[EPHEMERAL] Attachment workflow failed:', err);
    } finally {
      if (attachBtn) attachBtn.disabled = false;
      if (fileInput) fileInput.value = '';
    }
  });

  function renderAttachmentChips() {
    if (!attachmentSlot) return;
    attachmentSlot.innerHTML = '';

    const pending = ephemeralAttachments.filter(att => !att.pinned);
    if (!pending.length) {
      return;
    }

    for (const att of pending) {
      const chip = document.createElement('div');
      chip.className = 'composer-attachment-chip file-chip';
      chip.title = att.name;

      chip.innerHTML = `
        ${CLIP_SVG}
        <span class="sr-only">Attached file: </span>
        <span class="name"></span>
      `;
      const nameEl = chip.querySelector('.name');
      if (nameEl) {
        nameEl.textContent = truncateFilename(att.name, 32);
      }

      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.setAttribute('aria-label', `Remove ${att.name}`);
      removeBtn.textContent = 'x';
      removeBtn.addEventListener('click', () => removeAttachment(att));
      chip.appendChild(removeBtn);

      attachmentSlot.appendChild(chip);
    }
  }

  function clearAttachmentChip() {
    if (!attachmentSlot) return;
    attachmentSlot.innerHTML = '';
  }

  async function removeAttachment(att) {
    if (!conversationId) return;
    try {
      const res = await fetch(
        `/api/v1/lawfirm/ephemeral/${conversationId}/doc/${encodeURIComponent(att.doc_id)}`,
        { method: 'DELETE' }
      );
      if (!res.ok && res.status !== 404) {
        throw new Error(`Failed to remove attachment (${res.status}).`);
      }
    } catch (err) {
      console.error('[EPHEMERAL] Remove attachment failed:', err);
      alert('Failed to remove file.');
      return;
    }

    ephemeralAttachments = ephemeralAttachments.filter(a => a.doc_id !== att.doc_id);
    attachmentPinnedToMessage = ephemeralAttachments.length > 0 && !ephemeralAttachments.some(a => !a.pinned);
    renderAttachmentChips();
    persistAttachments();
    updateContextBanner();
    syncChatHasDocState();
  }

  function computeAttachmentSummary(includePinnedOnly = false) {
    const source = includePinnedOnly ? ephemeralAttachments.filter(att => att.pinned) : ephemeralAttachments;
    const total = source.length;
    if (!total) return null;
    if (total === 1) {
      return source[0].name || '1 document';
    }
    return `${total} documents`;
  }

  function persistAttachments() {
    if (!conversationId) return;
    if (!ephemeralAttachments.length) {
      delete attachmentCache[conversationId];
    } else {
      attachmentCache[conversationId] = ephemeralAttachments.map(att => ({
        doc_id: att.doc_id,
        name: att.name,
        pinned: !!att.pinned,
      }));
    }
    localStorage.setItem(ATTACHMENT_CACHE_KEY, JSON.stringify(attachmentCache));
  }

  function loadAttachmentsFromCache(id) {
    if (!id) return [];
    const stored = attachmentCache[id];
    if (!Array.isArray(stored)) return [];
    return stored.map(att => ({
      doc_id: att.doc_id,
      name: att.name,
      pinned: !!att.pinned,
    }));
  }

  function updateContextBanner() {
    if (!attachmentContextBanner) return;
    const pinnedCount = ephemeralAttachments.filter(att => att.pinned).length;
    if (!ephemeralAttachments.length || pinnedCount === 0) {
      hideAttachmentContextBanner();
      return;
    }
    const summary = computeAttachmentSummary(true);
    if (!summary) {
      hideAttachmentContextBanner();
      return;
    }
    showAttachmentContextBanner(summary);
  }

  function syncChatHasDocState(fallbackSummary) {
    if (!conversationId) return;
    const summary = computeAttachmentSummary() || fallbackSummary || null;
    const hasDoc = !!summary;
    const allPinned = hasDoc && !ephemeralAttachments.some(att => !att.pinned);
    setChatHasDoc(conversationId, hasDoc, summary || null, allPinned);
  }

  function showAttachmentContextBanner(name) {
    if (!attachmentContextBanner) return;
    const hasName = !!(name && typeof name === 'string' && name.trim());
    if (attachmentContextName) {
      if (hasName) {
        attachmentContextName.textContent = ` - ${truncateFilename(name, 36)}`;
        attachmentContextName.style.display = 'inline';
      } else {
        attachmentContextName.textContent = '';
        attachmentContextName.style.display = 'none';
      }
    }
    if (attachmentContextSeparator) {
      attachmentContextSeparator.style.display = hasName ? 'inline' : 'none';
    }
    attachmentContextBanner.style.display = 'flex';
  }

  function hideAttachmentContextBanner() {
    if (!attachmentContextBanner) return;
    attachmentContextBanner.style.display = 'none';
    if (attachmentContextName) {
      attachmentContextName.textContent = '';
      attachmentContextName.style.display = 'none';
    }
    if (attachmentContextSeparator) {
      attachmentContextSeparator.style.display = 'none';
    }
  }

  function syncAttachmentComposerWithStoredState() {
    if (!conversationId) {
      attachmentPinnedToMessage = false;
      ephemeralAttachments = [];
      hideAttachmentContextBanner();
      clearAttachmentChip();
      return;
    }
    ephemeralAttachments = loadAttachmentsFromCache(conversationId);
    attachmentPinnedToMessage = ephemeralAttachments.length > 0 && !ephemeralAttachments.some(att => !att.pinned);
    if (attachmentPinnedToMessage) {
      clearAttachmentChip();
      updateContextBanner();
    } else {
      renderAttachmentChips();
      hideAttachmentContextBanner();
    }
    syncChatHasDocState();
  }

  function truncateFilename(name, max = 28) {
    if (!name) return '';
    return truncate(name, max);
  }

  async function removeEphemeralDoc(conversationId) {
    if (!conversationId) return;

    if (inflightAttachmentController) {
      inflightAttachmentController.abort();
      inflightAttachmentController = null;
    }

    const response = await fetch(`${API}/ephemeral/${conversationId}`, {
      method: 'DELETE',
    });

    if (!response.ok && response.status !== 404) {
      let detail = '';
      try {
        const errJson = await response.json();
        detail = errJson?.detail || '';
      } catch (err) {
        detail = '';
      }
      throw new Error(detail || `Failed to remove ephemeral document (${response.status}).`);
    }

    setChatHasDoc(conversationId, false, null, false);
    console.log('[EPHEMERAL] Previous document context removed.');
    return response;
  }

  async function uploadEphemeral(files, { mode = 'append', remove = [], signal } = {}) {
    if (!conversationId) throw new Error('conversationId missing.');
    if (!Array.isArray(files) || !files.length) {
      throw new Error('No files provided.');
    }

    const form = new FormData();
    form.append('conversation_id', conversationId);
    form.append('user_id', userId);
    form.append('mode', mode);
    for (const file of files) {
      form.append('files', file, file.name);
    }
    if (Array.isArray(remove)) {
      for (const docId of remove) {
        if (docId) {
          form.append('remove_doc_ids', docId);
        }
      }
    }

    const controller = new AbortController();
    const handleExternalAbort = () => controller.abort();
    if (signal) {
      if (signal.aborted) {
        controller.abort();
      } else {
        signal.addEventListener('abort', handleExternalAbort);
      }
    }

    const timeoutId = setTimeout(() => controller.abort(), 75000);
    try {
      const response = await fetch(`${API}/ephemeral/upload`, {
        method: 'POST',
        body: form,
        signal: controller.signal,
      });

      if (!response.ok) {
        let errText = '';
        try {
          errText = await response.text();
        } catch (err) {
          errText = '';
        }
        if (errText) {
          throw new Error(`Upload failed (${response.status}): ${errText}`);
        }
        throw new Error(`Upload failed (${response.status}). Check /api/v1/lawfirm/ephemeral/ping.`);
      }

      return await response.json();
    } catch (error) {
      if (error?.name === 'AbortError') {
        throw error;
      }
      throw error instanceof Error ? error : new Error(String(error));
    } finally {
      clearTimeout(timeoutId);
      if (signal && !signal.aborted) {
        signal.removeEventListener('abort', handleExternalAbort);
      }
    }
  }

  async function detachEphemeralDoc() {
    if (!conversationId) return;
    if (!confirm('Detach and delete the ephemeral document for this chat?')) return;

    try {
      if (attachmentSlot) attachmentSlot.textContent = 'Removing...';
      if (attachBtn) attachBtn.disabled = true;

      await removeEphemeralDoc(conversationId);
      ephemeralAttachments = [];
      attachmentPinnedToMessage = false;
      hideAttachmentContextBanner();
      clearAttachmentChip();
      persistAttachments();
      syncChatHasDocState();
      if (attachmentSlot) {
        attachmentSlot.textContent = 'Attachments removed.';
        setTimeout(() => {
          if (attachmentSlot.textContent === 'Attachments removed.') {
            attachmentSlot.textContent = '';
          }
        }, 1500);
      }
    } catch (err) {
      console.error('[EPHEMERAL] Detach failed:', err);
      alert(err?.message || 'Failed to detach document.');
      showBanner(err?.message || 'Failed to detach document.');
      if (attachmentSlot) attachmentSlot.textContent = '';
    } finally {
      if (attachBtn) attachBtn.disabled = false;
    }
  }

  (async () => {
    try {
      const r = await fetchWithTimeout(`${API_ROOT}/healthz`, {}, 6000);
      if (!r.ok) {
        showBanner(`Health check failed (${r.status}).`);
      }
    } catch (e) {
      showBanner(`Cannot reach API (${e?.message || 'unknown error'}).`);
    }
  })();

  const CHAT_STATE_KEY = 'chat_state_meta';
  let chatState = {};
  try {
    chatState = JSON.parse(localStorage.getItem(CHAT_STATE_KEY) || '{}');
  } catch (e) {
    console.warn('[CHAT-STATE] Failed to parse chat state cache, resetting.', e);
    chatState = {};
  }

  const TWEAK_TRIGGERS = [
    'tweak','revise','modify','simplify','edit','tone','change','update','add','remove','replace'
  ];

  function getChatHasDoc(id) {
    return !!(chatState[id] && chatState[id].hasDoc);
  }

  function getChatDocName(id) {
    if (!id || !chatState[id]) return null;
    const name = chatState[id].docName;
    if (typeof name !== 'string') return null;
    const trimmed = name.trim();
    return trimmed ? trimmed : null;
  }

  function setChatHasDoc(id, value, docName, docPinned) {
    if (!id) return;
    const next = { ...(chatState[id] || {}), hasDoc: !!value };
    if (!next.hasDoc) {
      delete next.docName;
      delete next.docPinned;
    } else {
      if (docName !== undefined) {
        if (docName === null || (typeof docName === 'string' && docName.trim() === '')) {
          delete next.docName;
        } else {
          next.docName = docName;
        }
      }
      if (docPinned !== undefined) {
        next.docPinned = !!docPinned;
      }
    }
    chatState[id] = next;
    localStorage.setItem(CHAT_STATE_KEY, JSON.stringify(chatState));
  }

  function clearChatState(id) {
    if (!id || !chatState[id]) return;
    delete chatState[id];
    localStorage.setItem(CHAT_STATE_KEY, JSON.stringify(chatState));
    if (attachmentCache[id]) {
      delete attachmentCache[id];
      localStorage.setItem(ATTACHMENT_CACHE_KEY, JSON.stringify(attachmentCache));
    }
  }

  function ensureChatSubject(id, userInput) {
    if (!id) return;
    const currentSubject = getChatTitle(id);
    if (currentSubject && currentSubject.trim() && currentSubject.trim().toLowerCase() !== "new chat") {
      return;
    }

    const original = (userInput || "").trim();
    if (!original) {
      return;
    }

    const lower = original.toLowerCase();
    let subject = "New chat";
    if (lower.includes("legal notice")) subject = "Legal notice generation request";
    else if (lower.includes("suit")) subject = "Suit drafting request";
    else if (lower.includes("petition")) subject = "Petition drafting request";
    else if (lower.includes("application")) subject = "Application drafting request";
    else if (lower.includes("bail")) subject = "Bail application drafting request";
    else if (lower.includes("affidavit")) subject = "Affidavit preparation request";
    else subject = original.charAt(0).toUpperCase() + original.slice(1);

    updateSidebarTitle(id, subject);
    chatState[id] = { ...(chatState[id] || {}), subjectLocked: true };
    localStorage.setItem(CHAT_STATE_KEY, JSON.stringify(chatState));
  }

  // Helper to detect if text is HTML (starts with <html>, <div>, <!DOCTYPE, etc.)
  function isHtmlContent(text) {
    const trimmed = (text || '').trim();
    
    // Debug: log first 200 chars to see what we're getting
    console.log('[HTML-DETECT] First 200 chars:', trimmed.substring(0, 200));
    console.log('[HTML-DETECT] Starts with <:', trimmed.startsWith('<'));
    console.log('[HTML-DETECT] Contains </:', trimmed.includes('</'));
    console.log('[HTML-DETECT] Length:', trimmed.length);
    
    // Check for common HTML patterns that indicate document generation
    const isHtml = trimmed.startsWith('<!DOCTYPE') || 
           trimmed.startsWith('<html') || 
           trimmed.startsWith('<div>') ||
           trimmed.startsWith('<div ') ||
           trimmed.match(/^<p>/) ||
           trimmed.match(/^<ol>/) ||
           // More aggressive: if it starts with < and has HTML tags, treat as HTML
           (trimmed.startsWith('<') && (trimmed.includes('</p>') || trimmed.includes('</div>') || trimmed.includes('</ol>')) && trimmed.length > 100);
    
    console.log('[HTML-DETECT] Result:', isHtml);
    return isHtml;
  }

  function bubble(role, text, isMarkdown = false, referencedPages = null, documentName = null, responseType = null) {
    const div = document.createElement('div');
    div.className = 'bubble ' + (role === 'user' ? 'user' : 'assistant');

    const roleLabel = document.createElement('strong');
    roleLabel.textContent = role;
    div.appendChild(roleLabel);

    if (role === 'assistant' && isMarkdown) {
      const answerBox = document.createElement('div');
      answerBox.className = 'assistant-card answer-content';

      const treatAsHtml = responseType === 'html' || isHtmlContent(text);
      if (treatAsHtml) {
        answerBox.className = 'assistant-card answer-content html-document';
        answerBox.innerHTML = text;
        console.log('[HTML-DOC] Rendering as HTML document');

        const wrapper = document.createElement('div');
        wrapper.className = 'html-doc-wrapper';
        wrapper.style.position = 'relative';
        wrapper.appendChild(answerBox);

        const copyBtn = document.createElement('button');
        copyBtn.textContent = 'Copy';
        copyBtn.className = 'copy-doc-btn';
        Object.assign(copyBtn.style, {
          position: 'absolute',
          top: '10px',
          right: '16px',
          padding: '4px 10px',
          fontSize: '0.8rem',
          border: '1px solid var(--border)',
          borderRadius: '6px',
          background: 'var(--brand)',
          color: '#fff',
          cursor: 'pointer',
          opacity: '0.9',
          transition: 'opacity 0.2s ease',
          zIndex: '10'
        });

        copyBtn.onmouseenter = () => (copyBtn.style.opacity = '1');
        copyBtn.onmouseleave = () => (copyBtn.style.opacity = '0.9');

        copyBtn.addEventListener('click', async () => {
          try {
            const docText = answerBox.innerText || answerBox.textContent;
            await navigator.clipboard.writeText(docText.trim());
            copyBtn.textContent = 'Copied!';
            copyBtn.style.background = 'var(--success, #16a34a)';
            setTimeout(() => {
              copyBtn.textContent = 'Copy';
              copyBtn.style.background = 'var(--brand)';
            }, 1500);
          } catch (err) {
            console.error('[COPY] Failed:', err);
            copyBtn.textContent = 'Error';
          }
        });

        wrapper.appendChild(copyBtn);
        div.appendChild(wrapper);
        console.log('[COPY-BUTTON] Added for docgen bubble');
      } else {
        answerBox.innerHTML = marked.parse(text);
        console.log('[MARKDOWN] Rendering as markdown');
        div.appendChild(answerBox);
      }

      if (referencedPages || documentName) {
        const metaDiv = document.createElement('div');
        metaDiv.className = 'meta-row';
        const rows = [];
        if (referencedPages && referencedPages.length > 0) {
          rows.push(`Reference pages: ${referencedPages.join(', ')}`);
        }
        if (documentName) {
          const names = Array.isArray(documentName) ? documentName : [documentName];
          if (names.length) {
            rows.push(`Document${names.length > 1 ? 's' : ''}: ${names.join(', ')}`);
          }
        }
        metaDiv.textContent = rows.join(' | ');
        div.appendChild(metaDiv);
      }
    } else {
      const content = document.createElement('div');
      content.textContent = text;
      div.appendChild(content);

      if (role === 'user' && documentName) {
        const names = Array.isArray(documentName) ? documentName : [documentName];
        if (names.length) {
          const wrap = document.createElement('div');
          wrap.className = 'bubble-attachment-container';
          for (const name of names) {
            const chip = document.createElement('div');
            chip.className = 'bubble-attachment-chip file-chip';
            chip.title = name;

            chip.innerHTML = `
              ${CLIP_SVG}
              <span class="sr-only">Attached file: </span>
              <span class="name"></span>
            `;
            const nameEl = chip.querySelector('.name');
            if (nameEl) {
              nameEl.textContent = truncateFilename(name, 36);
            }

            wrap.appendChild(chip);
          }
          div.appendChild(wrap);
        }
      }
    }

    transcript.appendChild(div);
    transcript.scrollTop = transcript.scrollHeight;
  }

  /* --- Copy Button Styling Enhancements --- */
  const style = document.createElement('style');
  style.textContent = `
    .copy-doc-btn {
      background: var(--brand, #2563eb);
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 4px 10px;
      font-size: 0.8rem;
      cursor: pointer;
      opacity: 0.9;
      transition: background 0.2s ease, opacity 0.2s ease;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      z-index: 10;
    }
    .copy-doc-btn:hover {
      filter: brightness(1.05);
      opacity: 1;
    }
    .assistant-card.html-document {
      position: relative;
      z-index: 1;
      overflow: visible !important;
    }
    .html-doc-wrapper {
      position: relative;
    }
    .bubble.assistant {
      position: relative;
      overflow: visible !important;
    }
  `;
  document.head.appendChild(style);

  function escapeHtml(str) {
    return (str || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  async function listConversations() {
    try {
      const r = await fetch(`${API}/conversations?user_id=${encodeURIComponent(userId)}`);
      const data = await r.json();
      convList.innerHTML = '';
      
      if (data.length === 0) {
        const empty = document.createElement('div');
        empty.style.padding = '16px';
        empty.style.textAlign = 'center';
        empty.style.color = 'var(--muted)';
        empty.style.fontSize = '0.875rem';
        empty.textContent = 'No conversations yet';
        convList.appendChild(empty);
        return;
      }

      data.forEach(c => {
        const item = document.createElement('div');
        item.className = 'conv' + (c.id === conversationId ? ' active' : '');
        item.dataset.convId = c.id; // Add data attribute for easier selection
        if (getChatHasDoc(c.id)) {
          item.classList.add('has-doc');
        }
        
        const title = document.createElement('div');
        title.className = 'conv-title';
        // Use persisted title from localStorage if available
        title.textContent = getChatTitle(c.id);
        item.appendChild(title);

        const date = document.createElement('div');
        date.className = 'conv-date';
        const d = new Date(c.created_at);
        date.textContent = d.toLocaleDateString() + ' ' + d.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
        item.appendChild(date);

        // Delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-chat';
        deleteBtn.textContent = 'Delete';
        deleteBtn.title = 'Delete conversation';
        deleteBtn.onclick = async (e) => {
          e.stopPropagation();
          if (confirm('Delete this conversation?')) {
            await deleteConversation(c.id);
          }
        };
        item.appendChild(deleteBtn);

        item.onclick = async () => {
          conversationId = c.id;
          localStorage.setItem('conversation_id', conversationId);
          await loadMessages();
          await listConversations(); // Refresh to update active state
        };
        
        convList.appendChild(item);
      });
    } catch (e) {
      console.error('Failed to list conversations:', e);
    }
  }

  async function deleteConversation(convId) {
    try {
      await fetch(`${API}/conversations/${convId}`, {
        method: 'DELETE'
      });
      clearChatState(convId);
      if (attachmentCache[convId]) {
        delete attachmentCache[convId];
        localStorage.setItem(ATTACHMENT_CACHE_KEY, JSON.stringify(attachmentCache));
      }
      
      // If we deleted the current conversation, clear it
      if (convId === conversationId) {
        conversationId = null;
        localStorage.removeItem('conversation_id');
        transcript.innerHTML = '';
        syncAttachmentComposerWithStoredState();
        
        // Load first available conversation or create new one
        const r = await fetch(`${API}/conversations?user_id=${encodeURIComponent(userId)}`);
        const convs = await r.json();
        
        if (convs.length > 0) {
          conversationId = convs[0].id;
          localStorage.setItem('conversation_id', conversationId);
          await loadMessages();
        } else {
          await newConversation();
        }
      }
      
      await listConversations();
    } catch (e) {
      console.error('Failed to delete conversation:', e);
      alert('Failed to delete conversation. Please try again.');
    }
  }

  async function newConversation() {
    try {
      const r = await fetch(`${API}/conversations/new`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({user_id: userId})
      });
      const data = await r.json();
      conversationId = data.conversation_id;
      localStorage.setItem('conversation_id', conversationId);
      setChatHasDoc(conversationId, false, null, false);
      transcript.innerHTML = '';
      syncAttachmentComposerWithStoredState();
      await listConversations();
    } catch (e) {
      console.error('Failed to create conversation:', e);
    }
  }

  async function loadMessages() {
    if (!conversationId) {
      await newConversation();
      return;
    }
    
    try {
      const r = await fetch(`${API}/conversations/${conversationId}/messages`);
      const data = await r.json();
      transcript.innerHTML = '';
      syncAttachmentComposerWithStoredState();
      data.forEach(m => {
        // Check if message has markdown metadata (for assistant messages)
        const isMarkdown = m.role === 'assistant';
        const respType = (m?.metadata && m.metadata.response_type) || m?.response_type || null;
        const hasDocMeta = m?.metadata && Object.prototype.hasOwnProperty.call(m.metadata, 'has_doc') ? m.metadata.has_doc : undefined;
        const docNameFromMessage = m?.metadata?.document || null;
        if (typeof hasDocMeta === 'boolean') {
          setChatHasDoc(conversationId, hasDocMeta, hasDocMeta ? (docNameFromMessage ?? undefined) : null);
        } else if (respType === 'html') {
          setChatHasDoc(conversationId, true, docNameFromMessage ?? undefined);
        } else if (docNameFromMessage) {
          setChatHasDoc(conversationId, true, docNameFromMessage);
        }
        bubble(m.role, m.content, isMarkdown, null, null, respType);
      });
      syncAttachmentComposerWithStoredState();
    } catch (e) {
      console.error('Failed to load messages:', e);
    }
  }

  document.getElementById('newChat').onclick = newConversation;
  document.getElementById('refreshChats').onclick = listConversations;

  document.getElementById('send').onclick = send;
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      send();
    }
  });

  // Streaming helper - displays text word by word
  async function streamResponse(bubbleDiv, fullText, responseType = null) {
    const contentDiv = bubbleDiv.querySelector('.answer-content') || bubbleDiv.querySelector('div:last-child');
    if (!contentDiv) return;

    // Check if content is HTML - if so, render immediately without streaming
    const treatAsHtml = responseType === 'html' || isHtmlContent(fullText);
    if (treatAsHtml) {
      contentDiv.className = 'assistant-card answer-content html-document';
      contentDiv.innerHTML = fullText;

      let wrapper = contentDiv.parentElement;
      if (!wrapper || !wrapper.classList.contains('html-doc-wrapper')) {
        wrapper = document.createElement('div');
        wrapper.className = 'html-doc-wrapper';
        wrapper.style.position = 'relative';
        contentDiv.replaceWith(wrapper);
        wrapper.appendChild(contentDiv);
      }

      let copyBtn = wrapper.querySelector('.copy-doc-btn');
      if (!copyBtn) {
        copyBtn = document.createElement('button');
        copyBtn.textContent = 'Copy';
        copyBtn.className = 'copy-doc-btn';
        copyBtn.style.position = 'absolute';
        copyBtn.style.top = '10px';
        copyBtn.style.right = '16px';
        copyBtn.style.padding = '4px 10px';
        copyBtn.style.fontSize = '0.8rem';
        copyBtn.style.border = '1px solid var(--border)';
        copyBtn.style.borderRadius = '6px';
        copyBtn.style.background = 'var(--brand)';
        copyBtn.style.color = '#fff';
        copyBtn.style.cursor = 'pointer';
        copyBtn.style.opacity = '0.9';
        copyBtn.style.transition = 'opacity 0.2s ease';
        copyBtn.style.zIndex = '10';

        copyBtn.onmouseenter = () => (copyBtn.style.opacity = '1');
        copyBtn.onmouseleave = () => (copyBtn.style.opacity = '0.9');

        copyBtn.addEventListener('click', async () => {
          try {
            const docText = contentDiv.innerText || contentDiv.textContent || '';
            await navigator.clipboard.writeText(docText.trim());
            copyBtn.textContent = 'Copied!';
            copyBtn.style.background = 'var(--success, #16a34a)';
            setTimeout(() => {
              copyBtn.textContent = 'Copy';
              copyBtn.style.background = 'var(--brand)';
            }, 1500);
          } catch (err) {
            console.error('[COPY] Failed during streaming:', err);
            copyBtn.textContent = 'Error';
          }
        });

        wrapper.appendChild(copyBtn);
        console.log('[COPY-BUTTON] Added during streaming');
      }

      transcript.scrollTop = transcript.scrollHeight;
      console.log('[HTML-DOC] Rendered HTML document in streaming');
      return;
    }

    // Stream markdown content word by word
    const words = fullText.split(' ');
    let displayedText = '';
    
    // Add cursor
    const cursor = document.createElement('span');
    cursor.className = 'streaming-cursor';
    contentDiv.appendChild(cursor);

    for (let i = 0; i < words.length; i++) {
      displayedText += (i > 0 ? ' ' : '') + words[i];
      
      // Update content - use innerHTML for markdown-like formatting
      contentDiv.innerHTML = displayedText.replace(/\n/g, '<br>');
      contentDiv.appendChild(cursor);
      
      // Smooth scroll
      transcript.scrollTop = transcript.scrollHeight;
      
      // Word-by-word delay (adjust speed here)
      await new Promise(resolve => setTimeout(resolve, 30));
    }
    
    // Remove cursor and render final markdown
    cursor.remove();
    contentDiv.innerHTML = marked.parse(fullText);
  }

  // --- Sidebar title helpers with localStorage persistence ---
  function normalizeTitleFromText(text) {
    if (!text) return "New Chat";
    const words = text.trim().replace(/\s+/g, ' ').split(' ').slice(0, 7).join(' ');
    const capped = words.charAt(0).toUpperCase() + words.slice(1);
    return capped.length > 40 ? capped.slice(0, 37) + 'Î“Ã‡Âª' : capped;
  }
  
  function saveChatTitle(conversationId, title) {
    const map = JSON.parse(localStorage.getItem('chatTitles') || '{}');
    map[conversationId] = title;
    localStorage.setItem('chatTitles', JSON.stringify(map));
  }
  
  function getChatTitle(conversationId) {
    const map = JSON.parse(localStorage.getItem('chatTitles') || '{}');
    return map[conversationId] || "New Chat";
  }
  
  function updateSidebarTitle(conversationId, newTitle) {
    const item = document.querySelector(`[data-conv-id="${conversationId}"] .conv-title`);
    if (item) {
      if (item.textContent.trim() === "New Chat") {
        item.textContent = newTitle;
      }
    }
    saveChatTitle(conversationId, newTitle);
  }
  
  // Helper function to generate title from first user message (legacy support)
  function generateTitleFromMessage(text) {
    return normalizeTitleFromText(text);
  }
  
  // Update chat title in sidebar (only if it's "New Chat") - legacy support
  function updateChatTitleInSidebar(convId, newTitle) {
    updateSidebarTitle(convId, newTitle);
  }

  async function send() {
    const text = input.value.trim();
    if (!text) return;

    if (conversationId && getChatHasDoc(conversationId)) {
      const lower = text.toLowerCase();
      if (TWEAK_TRIGGERS.some(trigger => lower.includes(trigger))) {
        console.log('[DOC-TWEAK] Applying tweak to existing document context.');
      }
    }

    if (conversationId && getChatHasDoc(conversationId)) {
      const lower = text.toLowerCase();
      if (TWEAK_TRIGGERS.some(trigger => lower.includes(trigger))) {
        console.log('[DOC-TWEAK] Applying tweak to existing document context.');
      }
    }

    const pendingAttachments = ephemeralAttachments.filter(att => !att.pinned);
    const pendingNames = pendingAttachments.map(att => att.name);

    bubble('user', text, false, null, pendingNames);
    input.value = '';
    sendBtn.disabled = true;

    if (pendingAttachments.length) {
      for (const att of pendingAttachments) {
        att.pinned = true;
      }
      attachmentPinnedToMessage = ephemeralAttachments.length > 0 && !ephemeralAttachments.some(att => !att.pinned);
      renderAttachmentChips();
      persistAttachments();
      updateContextBanner();
      syncChatHasDocState();
    }

    if (!conversationId) await newConversation();

    // Create assistant bubble with loading
    const assistantDiv = document.createElement('div');
    assistantDiv.className = 'bubble assistant';
    const roleLabel = document.createElement('strong');
    roleLabel.textContent = 'assistant';
    assistantDiv.appendChild(roleLabel);
    
    const contentDiv = document.createElement('div');
    contentDiv.className = 'assistant-card answer-content';
    contentDiv.innerHTML = '<div style="display: flex; align-items: center; gap: 8px;"><span class="loading"></span><span>Thinking...</span></div>';
    assistantDiv.appendChild(contentDiv);
    
    transcript.appendChild(assistantDiv);
    transcript.scrollTop = transcript.scrollHeight;

    try {
      const storedConversation = localStorage.getItem('conversation_id');
      if (storedConversation) {
        conversationId = storedConversation;
      }

      const body = {
        query: text,
        conversation_id: conversationId,
        user_id: userId
      };
      
      const r = await fetch(`${API}/query`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(body)
      });
      
      const data = await r.json();

      // Update conversation_id from response
      if (data?.metadata?.conversation_id) {
        conversationId = data.metadata.conversation_id;
        localStorage.setItem('conversation_id', conversationId);
      }

      // Clear loading and stream response
      const content = data?.answer || '[no answer]';
      contentDiv.innerHTML = '';
      
      const responseType = data?.metadata?.response_type || null;
      const hasDocMeta = data?.metadata?.has_doc;
      const docNameFromMetadata = data?.metadata?.document || null;
      if (typeof hasDocMeta === 'boolean') {
        if (!hasDocMeta && ephemeralAttachments.length) {
          ephemeralAttachments = [];
          attachmentPinnedToMessage = false;
          renderAttachmentChips();
          persistAttachments();
          hideAttachmentContextBanner();
        } else if (hasDocMeta && attachmentPinnedToMessage) {
          updateContextBanner();
        }
      } else if ((responseType === 'html' || docNameFromMetadata) && attachmentPinnedToMessage) {
        updateContextBanner();
      }
      syncChatHasDocState(docNameFromMetadata || null);
      await streamResponse(assistantDiv, content, responseType);
      ensureChatSubject(conversationId, text);
      
      // Add metadata after streaming
      const pages = data?.metadata?.referenced_pages;
      const doc = docNameFromMetadata;
      const docType = data?.metadata?.doc_type;
      const references = Array.isArray(data?.metadata?.references) ? data.metadata.references.filter(Boolean) : [];
      
      if ((pages && pages.length) || doc || (docType && docType !== 'general') || references.length) {
        const metaDiv = document.createElement('div');
        metaDiv.className = 'meta-row';
        const rows = [];
        if (pages && pages.length > 0) {
          rows.push(`Reference pages: ${pages.join(', ')}`);
        }
        if (doc) {
          rows.push(`Document: ${doc}`);
        }
        if (docType && docType !== 'general') {
          rows.push(`Document type: ${docType.replace(/_/g, ' ')}`);
        }
        if (references.length > 0) {
          rows.push(`Referenced from: ${references.join(', ')}`);
        }
        metaDiv.textContent = rows.join(' | ');
        assistantDiv.appendChild(metaDiv);
      }
      
      // Refresh conversation list
      await listConversations();
    } catch (e) {
      console.error('Query error:', e);
      contentDiv.innerHTML = `Error: ${escapeHtml(e?.message || e)}`;
    } finally {
      sendBtn.disabled = false;
      input.focus();
    }
  }

  // Initialize
  (async function init() {
    try {
      console.log('[INIT] Starting initialization...');
      if (!conversationId) {
        console.log('[INIT] No conversation ID, creating new...');
        await newConversation();
      }
      console.log('[INIT] Loading conversations...');
      await listConversations();
      console.log('[INIT] Loading messages...');
      await loadMessages();
      console.log('[INIT] Initialization complete');
      input.focus();
    } catch (e) {
      console.error('[INIT] Initialization failed:', e);
      alert('Failed to initialize chat. Please refresh the page.');
    }
  })();

  // Auto-resize textarea
  input.addEventListener('input', function() {
    this.style.height = 'auto';
    this.style.height = Math.min(this.scrollHeight, 150) + 'px';
  });
  </script>

  <script>
    document.addEventListener('click', (event) => {
      const brandLink = event.target.closest('#brand-link');
      if (brandLink) {
        event.preventDefault();
        window.location.href = './index.html';
      }
    });
  </script>
  
</body>
</html>


